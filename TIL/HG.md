# 1월 셋째 줄 TIL (Today I Learned)

## 📅 날짜

### 2025-01-13

## ✏️ 오늘 한 일

- JIRA 에 대한 간단한 설명
- 기존 프로젝트의 디벨롭할 것인지, 새 프로젝트를 다시 기획할 것인지 논의.
  - 기존 프로젝트를 일단 디벨롭하는 방향으로 의견 수렴.
- 피그마: 기본 와이어프레임 제작.

## 📅 날짜

### 2025-01-14

## ✏️ 오늘 한 일

- 기획 컨펌 전 전체 방향 정돈
- 기획 컨펌
- 기획에 대한 방향성 재설립
- 아디이어 브레인스토밍

## 배운 점

- 기획에 대한 방향성

  - 타켓하려는 대상을 구체화.

  - WebRTC의 기능을 적극적으로 활용해도 괜찮다.

  - 폐기 아이디어 재고찰

  - MVP가 커야 한다. 규모를 채우기 위해 어거지 덕지덕지는 별로다.

  - 기존 서비스에 비해 차별성을 가져갈 수 있어야

- 새로운 아이디어 모색법: **브레인라이팅(Brainwriting)**

### 브레인라이팅(Brainwriting)

브레인라이팅은 브레인스토밍의 단점을 보완하기 위해 개발된 아이디어 발상법입니다. 이 기법은 참가자들이 주제에 대한 의견을 말하는 대신 종이에 적는 방식을 사용합니다.

**진행 방법**

1. 주제 또는 카테고리 선정
2. 참가자들이 일정 시간 동안 아이디어를 종이에 기록
3. 시간 종료 후 종이를 옆 사람에게 전달
4. 새로운 주제나 카테고리로 변경
5. 과정 반복
6. 모든 과정 종료 후 아이디어 공유 및 토론

### 장점

- **평등한 참여**: 모든 참가자가 동등하게 아이디어를 제시할 수 있음
- **균형 잡힌 의견 수렴**: 특정 인물에게 대화의 주도권이 돌아가는 것을 방지
- **소극적인 참가자 배려**: 말하기를 꺼리는 사람들도 자유롭게 의견을 낼 수 있음

브레인라이팅은 팀의 창의성을 극대화하고 다양한 아이디어를 체계적으로 정리하는 데 효과적인 방법입니다.

## 📅 날짜

### 2025-01-15

## ✏️ 오늘 배운 점

### GIT 특강

- GIT이 왜 필요한가?

  - 이력관리: 모든 기록은 저장된다

  - 분산버전 관리: 로컬 & 원격 저장소 활용과 협업

  - 협업 효율성: 여러 사람이 동시에 충돌 없이 작업이 가능하다

- GIT 기본 개념

  - 저장소: 코드의 역사와 현재를 담은 공간

  - 커밋: 변화의 순간을 포착하는 스냅샷

    - 고려사항:

      - 시점: 논리적으로 완결된 작업 단위

      - 횟수: 작은 단위로 자주 커밋

    - 구성 :

      - commit ID

      - 작성자 정보

      - 커밋 메세지

  - 브랜치: 아이디어를 실험하고 구현하는 독립적인 공간

  - 병합

- Git 사용 시 주의점:

  1. 커밋 메세지 작성 규칙: 명확하고 일관적인 메세지 작성이 중요

     - git config

     - conventional commits 참고하기

     - 본문이 선택이긴 하지만... 써 주세요

  2. 브랜치 전략: 명확한 브랜치 구조는 작업속도를 높이고 충돌을 최소화

     - 브랜치 과다 생성 시 관리 / 작업 복잡

     - `브랜치 전략`: git flow / gitlab flow / github flow

  - 효율적인 팀 협업 개발을 위해 커밋 규칙과 브랜치 전략 꼭 정하자

## 📅 날짜

### 2025-01-16

## ✏️ 오늘 배운 점

### 1. 생성형 Ai, 내 동료가 되어라

1. ChatGPT

- GPT-4o
- o1: 시간은 많이 드나 복잡한거 가능
- o1 미니

2. 이미지 생성

- DALL-E3
- Stable Diffusion: 무료지만 서버는 필요해요
- Mid journey: 프롬프트 기반이거나, 주어진 이미지 기반이거나

3. 노래 AI: Suno, Stable audio

   - 영상 포트폴리오

4. Claude: 월 구독제 but 20만 토큰

- 많은 용량 사용시 굳
- 개발 능력 특화
- `Artifacts 기능` -> 테트리스 게임
  - Remix Artifacts

5. 이미지 생성 AI `Editting`

- upscaling : 깨지지 않게 2배 3배 4배
- outpainting
- inpainting: 누끼, 객체 삭제
- 마스킹 따기
- Merging face -> 노비타 AI

6. 비디오 생성 AI

- KLING
- SORA

7. Gemini AI

- 아이언맨 자비스 같네 "저 조각상 뭐야?"
- PM 역할
- 게임도 만듦
- 로봇공학과의 융합

결론:  
**AI AGENT**

- 과거에는 텍스트, 이미지, 음악을 출력했으나,
- 이제 문제 해결과 복잡한 작업 실행에 초점을 둔다.

---

### 2. 개인 생산성 향상 기법

- 할 일, 공부할 것, 정보 너무 많다... ㅠㅠ

- 단순한 TODO 리스트보다 나은 방법은 없나?

1. **GTD**

- Get Things Done
- 할 일을 특정 알고리즘으로 분류
- is it actionable?
  - 버리거나 / 미루거나 / 위임해라
  - 이 기능이 Powerful
- 실제 가능한 업무에 대한 것만 집중하게끔 해줌.
- 이 기반으로 Todolist를 만드는 분들도 있음.
- `과감하게 버리는 / 위임하는` -> 부하 완화

2. **아이젠하워 매트릭스**

- `사분면`으로 나눔
- 긴박한가? 느긋한가?
- 중요한가? 안중요한가?
  - 긴박, 중요 : 해
  - 느긋, 중요: 스케쥴링
  - 느긋, 안중요: 삭제
  - 긴박, 안중요: 위임

3. **만트라트**

- 오타니
- 스도쿠같은데 `9분면`

4. **뽀모도로**

- `타이머 25분`

  5.**타임박싱**

- 업무는 주어진 시간만큼 증가하기 마련
- `일정 시간` 내에 특정 작업을 끝내겠다는 목표를 세우는 것
- 발등에 불 떨어뜨리기

6. **타임 블로킹**

- 자기 시간 확보
- `코어 타임`

7. **PARA METHOD**

- `Project`

  목표와 데드라인이 명확한 일들에 관한 노트가 여기에 속한다.  
   예를 들면, '이사하기', '블로그 글 작성', '이직', '여행 계획' 등이 있다.

- `Area`
  특정한 데드라인은 없지만 지속적으로 관심을 가져야 하는 영역이다.  
   '건강 관리', '재무 관리', '집안 일', '차량 유지', '가족 관계' 등의 주제가 여기에 해당된다.

- `Resource`
  특정 주제에 대한 관심사나 자료를 모아둔 카테고리이다.

- `Archive`
  더 이상 필요하지 않은, 완료된 프로젝트나 오래된 노트를 보관하는 곳이다.

8. **재텔카스텐**

- 독일어로 메모 상자

1. 임시적, 영구적 메모를 수시로 작성
2. 연관된 메모들을 index 카드로 관리
3. 연관된 메모들끼리도 사로 가리키게 기록

---

## 📅 날짜

### 2025-01-17

### ✏️ 오늘 한 거:

### 1. 프로젝트와 기술, 포폴

- 소크라테스

  - 산파술 (문답법)
    - 질문에 질문이 꼬리를 물어서 ...

- 면접관이 포트폴리오 볼 때에도 마찬가지이다.

  - 이 기술 왜 씀?
    - 왜 좋음?
      - 왜 빠름? ...

- 어떤 기술을 쓸 때 당위성이 있어야 함.

- FAQ1. 프로젝트가 많아야 할까요?

  - 좋을 수 있는 이유: 그 팀의 JD에 딱 맞는 포트폴리오를 제출할 수 있어서
  - 제출을 할 때에는 그 팀에 맞는 거 한 두개만 있어도 괜찮아요

- FAQ2. 프로젝트가 화려해야 할까요?

  - 새로운 기술...
  - 네니오?
    - 공채라면, 서류에서 필터링 안 되는게 중요할지도
    - 팀별 모집이라면, 그 팀에 맞는 기술 스택 혹은 비슷한 경험이 중요

- Base가 되는 포트폴리오 하나를 두고, 지원할때마다 조금씩 튜닝

### 2. 와이어프레임 제작

### 3. 유스케이스 설정

### 4. Media Recorder API 문서 공부

- IndexedDB key characteristics and basic terminology

---

## 📅 날짜

### 2025-01-21

### ✏️ 오늘 한 거:

# TIL: TypeScript, SWC, Axios, and Build Tools

## 1. TypeScript를 배워야 하는 이유

TypeScript를 배워야 하는 주요 이유는 다음과 같습니다:

1. **타입 안정성**: TypeScript는 정적 타입 검사를 통해 많은 버그를 사전에 방지할 수 있습니다. 연구에 따르면 일반적인 버그의 15%를 컴파일 단계에서 잡아낼 수 있다고 합니다.

2. **개발 생산성 향상**: 강력한 자동 완성과 인텔리센스 기능을 제공하여 개발 속도를 높이고 실수를 줄일 수 있습니다.

3. **코드 가독성과 유지보수성**: 타입 정의를 통해 코드의 의도를 명확히 표현할 수 있어 협업과 유지보수가 용이해집니다.

4. **대규모 프로젝트에 적합**: 복잡한 프로젝트에서 타입 시스템을 통해 코드의 구조를 더 잘 이해하고 관리할 수 있습니다.

5. **커뮤니티와 생태계**: TypeScript는 큰 커뮤니티와 풍부한 라이브러리 생태계를 가지고 있어 다양한 지원을 받을 수 있습니다.

## 2. SWC vs. Babel

SWC(Speedy Web Compiler)는 Rust로 작성된 빠른 JavaScript/TypeScript 컴파일러입니다. Babel과 비교하면 다음과 같은 특징이 있습니다:

1. **속도**: SWC는 Babel보다 훨씬 빠릅니다. 단일 스레드에서 약 20배, 멀티코어 환경에서 약 70배 빠르다고 알려져 있습니다.

2. **기능**: SWC는 Babel과 유사한 기능을 제공하지만, 일부 고급 플러그인은 지원하지 않을 수 있습니다.

3. **사용 편의성**: SWC는 설정이 간단하고 대부분의 경우 추가 구성 없이 사용할 수 있습니다.

4. **생태계**: Babel은 오랜 기간 사용되어 왔기 때문에 더 많은 플러그인과 커뮤니티 지원을 받고 있습니다.

## 3. CRA vs. Vite

Create React App(CRA)와 Vite는 React 프로젝트를 시작하는 데 사용되는 도구입니다. 주요 차이점은 다음과 같습니다:

1. **성능**: Vite가 CRA보다 훨씬 빠른 개발 서버 시작 및 빌드 시간을 제공합니다.

2. **구성**: CRA는 설정이 거의 필요 없지만, Vite는 더 유연한 구성을 제공합니다.

3. **번들링**: CRA는 Webpack을 사용하고, Vite는 Rollup과 esbuild를 사용합니다.

4. **생태계**: CRA는 더 오래되고 안정적인 생태계를 가지고 있지만, Vite는 빠르게 성장하고 있습니다.

5. **최신 기술 지원**: Vite는 ES 모듈을 네이티브로 지원하여 더 현대적인 개발 경험을 제공합니다.

결론적으로, 새로운 프로젝트에는 Vite를 사용하는 것이 성능과 개발 경험 측면에서 유리할 수 있습니다.

## 📅 날짜

### 2025-01-22

## ✏️ 오늘 배운 점

### 1. Commit Message Convention (Style) Guide

커밋 메시지 컨벤션은 프로젝트의 히스토리를 일관되게 관리하고 협업을 원활하게 하는 데 중요합니다. 주요 구성 요소는 다음과 같습니다:

1. **Type**: 커밋의 목적이나 내용을 나타냅니다.

   - feat: 새로운 기능 추가
   - fix: 버그 수정
   - docs: 문서 수정
   - style: 코드 포맷팅, 세미콜론 누락 등
   - refactor: 코드 리팩토링
   - test: 테스트 코드 추가
   - `chore`: 빌드 작업, 패키지 매니저 설정 등

2. **Scope**: 커밋이 영향을 미치는 범위를 나타냅니다 (선택사항).

3. **Subject**: 변경사항에 대한 간결한 설명입니다.

4. **Body**: 변경사항에 대한 자세한 설명입니다 (선택사항).

5. **Footer**: 주요 변경사항이나 Breaking Changes를 명시합니다 (선택사항).

예시:

```
feat(user): 사용자 로그인 기능 추가

- 이메일과 비밀번호를 이용한 로그인 구현
- JWT 토큰 발급 및 저장 로직 추가

Closes #123
```

이러한 컨벤션을 따르면 코드 리뷰, 버전 관리, 릴리즈 노트 작성 등이 더욱 효율적으로 이루어질 수 있습니다.

### 2. [React] Prop Drilling 이란 무엇이고, 어떻게 해결할 수 있을까?

Prop Drilling은 React 애플리케이션에서 `상위 컴포넌트의 state를 여러 단계의 하위 컴포넌트로 전달해야 할 때 발생`하는 문제입니다. 이는 코드의 가독성을 떨어뜨리고 유지보수를 어렵게 만들 수 있습니다.

해결 방법:

1. `**Context API**`: React의 내장 기능으로, 전역 상태를 관리하고 필요한 컴포넌트에 직접 제공할 수 있습니다.

2. `**상태 관리 라이브러리**`: Redux, MobX, Recoil 등을 사용하여 전역 상태를 효율적으로 관리할 수 있습니다.

3. **컴포넌트 구조 재설계**: 상태를 사용하는 컴포넌트들을 가능한 한 가까이 배치하여 prop drilling을 최소화합니다.

4. **Render Props 패턴**: 컴포넌트의 렌더링 로직을 props로 전달하여 재사용성을 높이고 prop drilling을 줄일 수 있습니다.

5. **Hooks 사용**: Custom Hooks를 만들어 상태 로직을 재사용하고 컴포넌트 간 공유를 쉽게 할 수 있습니다.

## 불필요한 렌더링 최소화

Zustand는 상태 변화에 따른 불필요한 컴포넌트 렌더링을 효과적으로 최소화합니다. 이는 특히 대규모 애플리케이션에서 성능을 크게 향상시키는 중요한 특징입니다

### Zustand의 렌더링 최적화 방식

1. **선택적 구독**: Zustand는 컴포넌트가 실제로 사용하는 상태 부분만 구독하도록 합니다. 이를 통해 관련 없는 상태 변경으로 인한 불필요한 리렌더링을 방지합니다[2].

2. **얕은 비교**: Zustand는 기본적으로 얕은 비교를 사용하여 상태 변경을 감지합니다. 이는 불필요한 리렌더링을 줄이는 데 도움이 됩니다[14].

3. **성능 최적화된 구조**: Zustand는 내부적으로 Proxy 기반 시스템을 사용하여 상태 변경을 추적하고, 필요한 경우에만 컴포넌트를 리렌더링합니다[8].

### useStore 훅의 활용

useStore 훅을 사용하면 상태 업데이트가 UI 렌더링을 일으키지 않도록 세밀하게 제어할 수 있습니다:

```javascript
const bears = useStore(
  (state) => state.bears,
  (oldBears, newBears) => oldBears === newBears
);
```

이 방식을 통해 특정 조건에서만 리렌더링이 발생하도록 설정할 수 있습니다[15].

### Context API와의 비교

Context API를 사용할 때 흔히 겪는 리렌더링 문제와 달리, Zustand는 이러한 문제를 효과적으로 해결합니다. Context API는 상태가 변경될 때마다 해당 Context를 사용하는 모든 컴포넌트가 리렌더링되는 반면, Zustand는 실제로 변경된 상태를 사용하는 컴포넌트만 리렌더링합니다[19][26].

### 대규모 애플리케이션에서의 이점

복잡하고 큰 규모의 애플리케이션에서 Zustand의 이러한 특성은 특히 유용합니다. 불필요한 리렌더링을 줄임으로써 애플리케이션의 전반적인 성능과 반응성을 크게 향상시킬 수 있습니다[7][23].

Context API를 사용했던 프로젝트에서 리렌더링 관련 문제로 어려움을 겪었다면, Zustand로의 전환은 이러한 문제를 해결하는 데 큰 도움이 될 수 있습니다. Zustand의 효율적인 상태 관리와 렌더링 최적화는 개발자들에게 상당한 이점을 제공합니다[24][37].

## 📅 날짜

### 2025-01-23

## ✏️ 오늘 배운 점

### 1. 코드 리뷰 및 커밋

#### 코드 리뷰란

코드 리뷰는 개발자들이 서로의 코드를 검토하고 피드백을 주는 과정입니다. 이는 코드 품질 향상과 팀 협업 강화를 위한 중요한 실무입니다.

#### 기대효과

- 버그 조기 발견 및 수정
- 코드 품질 향상
- 지식 공유 및 팀 역량 강화
- 일관된 코딩 스타일 유지

#### 코딩 컨벤션

팀 내에서 일관된 코드 작성을 위한 규칙으로, 가독성과 유지보수성을 높입니다.

#### 좋은 코드란

- 가독성이 높고 이해하기 쉬운 코드
- 효율적이고 성능이 좋은 코드
- 유지보수가 용이한 코드
- 확장성이 있는 코드

#### 코드 리뷰의 필요성

- 코드 품질 보장
- 팀 내 지식 공유
- 일관성 있는 코드베이스 유지
- 개발자 간 상호 학습

#### 코드 리뷰 참여자의 자세

1. Reviewer로서:

   - 객관적이고 건설적인 피드백 제공
   - 코드의 장단점을 균형있게 평가
   - 개선 제안 시 명확한 이유 제시

2. Reviewee로서:

   - 열린 마음으로 피드백 수용
   - 필요시 추가 설명이나 컨텍스트 제공
   - 개선 제안에 대해 적극적으로 대응

3. 팀원으로서:

   - 상호 존중과 신뢰 구축
   - 지속적인 학습과 개선 노력
   - 팀의 코딩 표준 준수

4. 개발자로서:
   - 최신 기술 트렌드 파악
   - 코드 품질에 대한 높은 기준 유지
   - 지속적인 자기 개발

### 2. Design Convention

피그마를 이용한 데스크톱 및 웹 애플리케이션 디자인 시 준수해야 할 규약:

1. 간격 및 크기:

   - 모든 간격과 글꼴 크기는 4px의 배수로 설정
   - 이는 일관된 레이아웃과 가독성 향상에 도움

2. 색상 체계:

   - 일관된 색상 팔레트 사용
   - 주요 색상, 보조 색상, 강조 색상 등을 명확히 정의

3. 타이포그래피:

   - 제목, 본문, 버튼 등 각 요소별 일관된 폰트 스타일 적용
   - 글꼴 크기의 계층 구조 설정 (예: 제목 24px, 부제목 18px, 본문 16px)

4. 그리드 시스템:

   - 12칼럼 또는 8칼럼 그리드 시스템 활용
   - 반응형 디자인을 위한 브레이크포인트 설정

5. 컴포넌트 디자인:

   - 재사용 가능한 UI 컴포넌트 제작
   - 버튼, 입력 필드, 카드 등의 일관된 스타일 가이드 준수

6. 아이콘 및 이미지:

   - 일관된 스타일의 아이콘 세트 사용
   - 이미지 크기 및 비율 표준화

7. 상호작용 디자인:

   - 호버, 클릭, 포커스 등의 상태에 대한 일관된 시각적 피드백 제공

8. 접근성:
   - 색상 대비, 글꼴 크기 등 WCAG 가이드라인 준수

이러한 디자인 컨벤션을 준수함으로써 일관성 있고 전문적인 사용자 인터페이스를 구현할 수 있습니다.

## 📅 날짜

### 2025-01-24

## ✏️ 오늘 배운 점

### 1. 애자일 개발

#### 1-1. 애자일 개발이란

- 스프린트라는 일정주기를 통해 설계, 개발, 테스트를 반복해 프로젝트를 완성하는 작업
- 고객과의 즉각적인 소통과 피드백을 통해 요구사항을 신속하게 반영할 수 있음

#### 1-2. 등장배경

- 폭포수 개발론
- 폭포수 개발론과의 차이
- 폭포수 개발론은 무조건 나쁜가?

#### 1-3. 애자일 개발의 장단점

- 장점: 빠른 피드백, 빠른 소통, 제품을 빠르게 출시
- 단점: 반복적인 작업으로 번아웃이 쉽게 옴

#### 1-4. 애자일 프레임워크

- MVP
- SPRINT
- 스크럼
- TDD
- Copilot
- Devops

### 2. 톡식하지 않는 개발자 되기

#### 무의식이 결정을 먼저 내리고 의식이 한다.

- FACT는 사실 우리의 느낌, 감일 수 있어요

#### 팩트에 팩트만 있나?

- 팩트와 묘하게 평가가 들어갈 수 있음.
- "니 제대로 이해한거 맞음? 그건…"

#### 톤 앤 매너

- 건설적인 피드백도 아프긴 한데…
- 근데 안 아프게 얘기할 수 있어요

##### I-statement

- 나 전달법

##### 공통의 목표 환기하기

- "우리 팀이 X를 하고 싶다는 걸 생각했을 때," 이렇게 하는 게 더 좋겠어

##### 상대의 입장 확인하기

- "아마 이러이러한 상황 때문에 이렇게 한 것 같은데," 이렇게 하는 게 더 좋겠어.

#### 그 외 버려야 할 태도

##### 사무적/기계적으로 말하는 것

- "안녕 패트, 네 사촌이 죽었다."
  - 직선적이고 사무적인 말투가 효율적일지라도 궁극적으로 팀 분위기를 헤쳐요
- 타인의 감정을 배려한 말투를 씁시다
  - 기계적인 말투보다 **우리 모두의 생산성**을 증대할 수 있어요

###### 그럼 어케 해 : 칭찬

- 상대가 잘한 부분을 크게 말해줄 수 있는 배포

##### 습관적 비관

- "그냥 안 될 것 같은데요"
  - bias일 수 있어요
- **실패 염려에 대한 대안 제시**까지 있어야 좋아요

##### 거들먹, 빈정거림

- "A는 공부 참 많이 하셨네요 ^^, 근데 그건 옛날거에요 ^^"
  - 상대의 노력을 뭉뚱그려 무시하는 거에요

##### 수동적 공격성

- 적개심, 불만을 품은 대상에게 **간접적인** 방법을 통해 불편하게 만드는 행동 양식
- "아 정말 괜찮아" (한숨을 엄청나게 쉬며) 딩딩딩딩딩
- 기가 세거나 재치있는게 아니에요 ㅠㅠ
  - 투명하게 소통하지 못하는 거에요.


## 📅 날짜

### 2025-01-31

## ✏️ 오늘 배운 점

### React와 MediaPipe를 이용한 웹캠 자세 감지 애플리케이션

1. **React Hooks 활용**

- `useRef`: 비디오와 캔버스 요소에 대한 참조를 생성하여 DOM 조작에 사용
- `useState`: 자세 감지기, 비디오 스트림, 마지막 처리 시간 등의 상태 관리
- `useCallback`: 자세 감지 함수의 불필요한 재생성 방지 및 성능 최적화
- `useEffect`: 컴포넌트 마운트 시 카메라 설정 및 자세 감지기 로드

2. **MediaStream API**

- `navigator.mediaDevices.getUserMedia`: 웹캠 접근 및 비디오 스트림 획득
- 비디오 요소의 `srcObject` 속성을 통한 스트림 연결

3. **MediaPipe 라이브러리 활용**

- `FilesetResolver`: WASM 모듈 로드 및 초기화
- `PoseLandmarker`: 자세 감지 모델 생성 및 설정
- GPU 위임을 통한 성능 최적화

4. **Canvas API**

- 2D 컨텍스트를 이용한 그래픽 처리
- `drawLandmarks`와 `drawConnectors` 함수를 통한 자세 랜드마크 및 연결선 그리기
- 캔버스 변환(translate, scale)을 통한 이미지 반전 처리

5. **성능 최적화 기법**

- `requestAnimationFrame`을 이용한 효율적인 애니메이션 루프 구현
- 중복 프레임 처리 방지를 위한 타임스탬프 비교

6. **리소스 관리**

- 녹화 중지 시 모든 미디어 트랙 정지 및 리소스 해제

7. **React 컴포넌트 구조화**

- 기능별 로직 분리 (카메라 설정, 자세 감지기 로드, 자세 감지 및 그리기)
- JSX를 통한 선언적 UI 구성

8. **타입스크립트 활용**

- 제네릭을 이용한 타입 안정성 확보 (예: `useRef<HTMLVideoElement | null>`)
- 인터페이스 및 타입 정의를 통한 코드 가독성 및 유지보수성 향상

이 프로젝트를 통해 React, MediaPipe, 그리고 웹 API들을 종합적으로 활용하여 실시간 자세 감지 애플리케이션을 구현하는 방법을 학습했습니다. 특히 성능 최적화와 리소스 관리에 주의를 기울여 효율적인 웹 애플리케이션 개발 방법을 익혔습니다.

## 📅 날짜

### 2025-02-03

### ✏️ 오늘 한 거:

# 1: Java와 Python의 최신 기능

## 1. Java의 새로운 기능

### Virtual Thread

Virtual Thread는 Java의 기존 스레드 모델을 확장한 경량 스레드입니다. 

**기존 모델**: JVM -> OS -> CPU
**현재 모델**: Virtual Thread -> JVM -> OS -> CPU

Virtual Thread는 JVM 레벨에서 관리되는 경량 스레드로, 다음과 같은 장점을 제공합니다:

1. **더 많은 스레드**: 수천에서 수백만 개의 스레드를 효율적으로 생성하고 관리할 수 있습니다.
2. **적은 메모리 사용**: 가상 스레드는 약 10KB의 메모리만 사용하여 기존 스레드(약 2MB)보다 훨씬 적은 메모리를 소비합니다.
3. **빠른 컨텍스트 스위칭**: JVM 내부에서 스케줄링되어 컨텍스트 스위칭 비용이 크게 감소합니다.
4. **쉬운 적용**: 기존 Java 코드에 최소한의 변경으로 통합할 수 있습니다.

### Record

Record는 Java 14에서 도입된 새로운 종류의 클래스 타입으로, 데이터를 간결하게 표현할 수 있게 해줍니다.

주요 특징:

1. **불변성**: Record로 생성된 객체는 기본적으로 불변입니다.
2. **동시성**: 불변 객체이므로 멀티스레드 환경에서 안전하게 사용할 수 있습니다.
3. **패턴 매칭**: Java 16부터 도입된 패턴 매칭과 함께 사용하여 데이터 추출을 간소화할 수 있습니다.
4. **레코드 패턴**: Java 17에서 preview로 도입된 기능으로, 레코드의 구조를 더 쉽게 분해할 수 있습니다.
5. **Sealed Class**: Java 15에서 도입된 기능으로, 레코드와 함께 사용하여 타입 계층을 제한할 수 있습니다.

## 2. Python의 최신 기능

### No GIL Python (Global Interpreter Lock)

- **정의**: GIL은 Python 인터프리터가 한 번에 하나의 스레드만 실행할 수 있도록 하는 메커니즘입니다. No GIL Python은 이 제한을 제거하려는 시도입니다.
- **특징**: 멀티코어 시스템에서 진정한 병렬 처리를 가능하게 하여 성능을 크게 향상시킬 수 있습니다.
- **한계**: 아직 실험 단계에 있으며, 기존 Python 코드와의 호환성 문제 등 해결해야 할 과제가 남아있습니다.

### Type Hints

Python의 타입 힌트는 동적 타이핑 언어인 Python에 정적 타입 검사 기능을 추가합니다.

**Python의 장점**:
- 읽고 쓰기 쉬움
- 빠른 개발 속도
- 건강한 생태계

**Type Hints의 장점**:
- 코드의 안정성 향상
- IDE 지원 향상으로 개발 생산성 증가
- 코드 가독성 극대화

**Type Hints의 특징**:
- 강제성이 없음: 실행 시 영향을 주지 않습니다.
- 타입 명시(힌트): 변수, 함수 매개변수, 반환값 등에 타입을 명시할 수 있습니다.
- 실행 시 영향 없음: 타입 힌트는 런타임에 검사되지 않습니다.
- 정적 검사기로 오류 확인: mypy와 같은 도구를 사용하여 타입 관련 오류를 사전에 확인할 수 있습니다.


# 2: 효과적인 코드 리뷰 방법

## 코드 리뷰의 중요성

코드 리뷰는 단순히 잘못된 점을 찾는 과정이 아닙니다. 이는 팀원 간의 학습과 커뮤니케이션을 위한 중요한 도구입니다.

- **학습 기회**: 신입 개발자들은 선배들의 코드를 리뷰하며 많은 것을 배울 수 있습니다.
- **긍정적 피드백**: 잘한 부분에 대한 칭찬도 좋은 리뷰의 일부입니다.
- **커뮤니케이션 도구**: 코드 리뷰는 코드를 매개로 한 효과적인 커뮤니케이션 수단입니다.

## 효율적인 코드 리뷰 프로세스

### 리뷰 대기 시간 활용
- 여러 태스크를 병행하며 리듬 찾기
- 한 태스크가 리뷰 중이라면 다른 태스크 시작하기
- 리뷰어는 빠른 초기 응답 제공하기

### 좋은 코드 작성 팁
1. **코드 길이 제한**: 500~800라인 정도로 유지
2. **추상화**: 복잡성을 단순함으로 감추기
3. **다양한 설명 수단 활용**: UML, 스크린샷 등 활용

### 효과적인 리뷰 방법
- 모멸감을 주지 않는 언어 사용
- 코멘트에 이유 포함하기
- 개선 방향 함께 제시하기

## 추가 팁

### 브랜치 관리
- 공통 브랜치(feature/dev/staging) 병합 시 항상 코드 리뷰 진행

### PR/MR 관리
- 제목에 이모지로 카테고리 표현 (예: 🆕 신규 기능, 🐛 버그 수정)

### 코멘트 카테고리화
- nit: 사소한 지적사항
- thinking out loud: 즉흥적 아이디어
- optional: 선택적 제안
- question: 단순 질문

### 시간 관리
- 코드 리뷰 응답 시간 제한 설정
- 정기적인 코드 리뷰 시간 배정

이러한 방법들을 통해 코드 리뷰는 팀의 생산성과 코드 품질을 높이는 효과적인 도구가 될 수 있습니다.

## 📅 날짜

### 2025-02-04

### ✏️ 오늘 한 거:

#### .env 파일과 환경별 Path 설정 관리

##### 1. .env 파일의 기본 구성요소
- API 키 및 시크릿 (예: KAKAO_API_KEY)
- 데이터베이스 접속 정보
- 서버 포트 설정
- 환경 구분자 (NODE_ENV)
- 경로(path) 설정값

##### 2. Path 설정 방법
1. **기본 구조**
```javascript
paths: {
    uploads: process.env.NODE_ENV === 'production' 
      ? '/var/www/uploads'  // 프로덕션 경로
      : './uploads',        // 개발 환경 경로
}
```

2. **주요 path 종류**
- uploads: 파일 업로드 저장 경로
- static: 정적 파일 경로 (이미지, CSS, JS)
- logs: 로그 파일 저장 경로
- views: 템플릿 파일 경로
- temp: 임시 파일 저장 경로

##### 3. 환경별 관리 방법
1. **환경별 .env 파일 분리**
```plaintext
.env.development
.env.production
.env.test
```

2. **설정 관리 도구**
- node-config: 환경별 설정을 JSON/YAML로 관리
- dotenv-flow: 다중 .env 파일 자동 로드

##### 4. 주의사항
- path.join 또는 path.resolve 사용으로 운영체제 호환성 확보
- 민감한 정보는 반드시 .gitignore에 포함
- 환경별 기본값 설정 필요

##### 5. 장점
- 환경에 따른 자동 경로 전환
- 하드코딩 제거로 유지보수성 향상
- 중앙화된 경로 관리
- 배포 환경 변경 시 설정 파일만 수정



## 📅 날짜

### 2025-02-05

### ✏️ 오늘 한 거:

#### 프로젝트 발표 피드백 정리

##### 1. 발표 스킬 개선 포인트

###### 긍정적인 부분
- 전달력이 좋고 목소리 톤이 안정적

###### 개선이 필요한 부분
- 긴장한 기색이 겉으로 드러남 (숨이 차 보이거나 제스처가 크고 빨라짐)
- 청중이 아닌 다른 곳을 응시하거나 시연자를 쳐다보는 모습에서 불안정한 느낌 발생

###### 개선 팁
- **효과적인 제스처 사용법**:
  - 강조하고 싶은 부분에서만 의도적으로 사용
  - 동작은 몸통에서 팔 반쪽 범위 내에서 사용
  - 한 동작을 빠르게 하기보다는 천천히 + 일시정지하고 잠시 머무르기
- **시선 처리**:
  - 힘들면 한 명만 집중해서 응시하거나 한 곳을 바라보는 연습
- **리허설 중요성**:
  - 충분한 리허설로 긴장감 완화 필요

##### 2. 발표 자료(장표) 개선 포인트

###### 긍정적인 부분
- 첫 시작을 수치로 표현하여 가독성 좋음
- 장표가 발표 흐름을 잘 담고 있음
- 퀄리티가 평균 이상

###### 개선이 필요한 부분
- 폰트 크기 조절 필요
- 프로젝터로 인한 색 표현 문제

###### 개선 팁
- 폰트 크기에 따른 가독성 고려
- 색깔 사용 최소화, 대신 강조하고 싶은 부분을 Bold, 크기, 서체 등으로 표현
- 레이아웃 통일화

##### 3. 시연 및 Q&A 개선 포인트

###### 긍정적인 부분
- 서비스에 대해 명확히 인지되는 시연
- 시연자와 발표자의 발표 크로스 부분에서 브릿지 멘트 좋음

###### 개선이 필요한 부분
- 시연자와 발표자의 호흡 개선 필요
- Q&A 대응 강화 필요

###### 개선 팁
- 본선 발표회 구조를 고려한 발표자 선정
- Q&A 예상 질문을 미리 장표로 준비
- 담당자들의 상시 대기로 즉각적인 질문 대응 준비

이번 피드백을 통해 발표 스킬, 자료 구성, 시연 및 Q&A 대응 등 다양한 측면에서 개선점을 파악할 수 있었습니다. 이를 바탕으로 향후 발표 준비에 적용하여 더욱 효과적인 프레젠테이션을 할 수 있도록 노력해야겠습니다.



## 📅 날짜

### 2025-02-06

### ✏️ 오늘 한 거:

#### Styled Components 관련 이슈 해결

##### 1. shouldForwardProp 사용 문제

###### 에러 상황
`.withConfig({ shouldForwardProp: (prop) => prop !== "isActive" })<TabProps>` 를 사용하지 않았을 때, 불필요한 prop이 DOM 요소로 전달되어 콘솔에 경고가 발생할 수 있습니다.

###### Styled Components의 자체적인 문제
Styled Components는 기본적으로 모든 props를 DOM 요소로 전달합니다. 이는 불필요한 속성이 HTML 요소에 추가되는 문제를 야기할 수 있습니다.

###### 해결 방안 및 코드의 의미
```typescript
.withConfig({
  shouldForwardProp: (prop) => prop !== "isActive",
})<TabProps>`
```
이 코드는 `isActive` prop을 제외한 모든 prop을 DOM 요소로 전달하도록 지정합니다. 이를 통해:
- 불필요한 prop이 DOM에 전달되는 것을 방지합니다.
- 콘솔 경고를 제거할 수 있습니다.
- 컴포넌트의 타입 안정성을 향상시킵니다.

##### 2. Styled Components의 className 암호화 방지

###### 문제 상황
개발 시 Styled Components는 기본적으로 className을 암호화하여 생성합니다. 이로 인해 개발자 도구에서 스타일을 디버깅하기 어려워질 수 있습니다.

###### 다양한 해결 방법
1. **babel-plugin-styled-components 사용**
   - webpack 설정에 babel 플러그인을 추가합니다.
   ```javascript
   {
     plugins: ['babel-plugin-styled-components']
   }
   ```
   - 이 플러그인은 className을 더 읽기 쉬운 형태로 생성합니다.

2. **Styled Components의 GlobalStyle 사용**
   ```javascript
   import { createGlobalStyle } from 'styled-components';

   const GlobalStyle = createGlobalStyle`
     body {
       /* 전역 스타일 정의 */
     }
   `;
   ```
   - 전역 스타일을 정의하여 일관된 스타일링을 적용할 수 있습니다.

3. **displayName 속성 사용**
   ```javascript
   const StyledButton = styled.button`
     /* 스타일 정의 */
   `;
   StyledButton.displayName = 'StyledButton';
   ```
   - 컴포넌트에 displayName을 지정하여 개발자 도구에서 식별하기 쉽게 만듭니다.

###### 확장 프로그램으로 해결
"Styled Components" 브라우저 확장 프로그램을 설치하여 개발자 도구에서 Styled Components의 className을 쉽게 식별할 수 있습니다. 이 확장 프로그램은:
- className의 암호화를 해제하여 원래의 컴포넌트 이름을 표시합니다.
- 스타일 디버깅을 용이하게 합니다.
- 추가적인 코드 수정 없이 개발 환경을 개선할 수 있습니다.

이러한 방법들을 통해 Styled Components를 사용하면서 발생할 수 있는 문제들을 효과적으로 해결할 수 있습니다.
