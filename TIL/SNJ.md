# 📘 TIL (Today I Learned)

## 📅 2025.01.13.MON
- 프로젝트의 기획이 생각보다 고려해야 할 점이 많다는 것을 깨달았던 하루였습니다...
- JIRA 사용법에 대해 아직 익숙하지 않은 상태였는데, 에픽, 백로그 등의 개념 및 간단한 사용 방법들을 배워보고 실습해보았습니다.
<br/>
<br/>

## 📅 2025.01.14.TUE
### PM 특강
1. 문제해결/협력
    1) 특징
        - win-win (최선의 선택)
        - 아이디어나 정보 공유
        - 문제나 갈등을 도전의 기회로 인식
    2) 선택해야 하는 상황
        - 이해관계자에게 중대하고 반드시 극복해야 하는 갈등이 있을 때
        - 갈등해결 과정이 배움으로 큰 의미를 가질 때
        - 프로젝트 계획수립 단계의 핵심 의사결정
    3) 주의 사항
        - 갈등 해결에 오랜 시간과 노력이 필요

2. 강압/경쟁
    1) 특징
        - 내가 옳고 상대가 틀린 것을 분명히 함
        - 권력/지위를 사용
        - 상대의 굴복을 강요
    2) 선택해야 하는 상황
        - 긴급한 의사결정을 해야 하는 갈등 (안전과 관련된 사안)
        - 모든 이해관계자가 하기 싫어하는 일을 해야 할 때 (원가절감 등)
        - 내가 경쟁에서 승리할 확률이 최소 70% 이상일 때
    3) 주의 사항
         - 부정적인 효과가 매우 오래 지속됨

3. 회피/지연
    1) 특징
        - 조만간 없어지리라 생각할 때
        - 해결책을 모색하는 중일 때
        - 문제를 회피하는 모습을 감춰야 하는 경우
    2) 선택해야 하는 상황
        - 사소하거나 중요도가 낮은 갈등
        - 갈등으로 감정이 이미 격양된 상태일 때
        - 갈등 해결의 가망성이 매우 희박한 경우
    3) 주의 사항
        - PM이 매우 소극적인 사람으로 인식될 수 있음

4. 수용/수습
    1) 특징
        - 내 잘못이 분명할 때
        - 항복할 때
        - 아쉽지만 협력관계를 유지할 필요가 있을 때
    2) 선택해야 하는 상황
        - 과거에 대한 교훈과 미래의 신뢰를 구축해야 하는 상황
        - 내 잘못이 명백하여 조직 내 평판이 나빠지는 것을 막아야 하는 경우
    3) 주의 사항
        - 태도의 진정성에 대해 의심받을 수 있음 (금전적 보상을 함께하자...)

5. 타협/절충
    1) 특징
        - 갈등이 애매한 경우
        - 협상할 때
        - 거래나 교환을 추구하는 경우
    2) 선택해야 하는 상황
        - 중요한 갈등이나 해결을 위한 노력을 최소화 하고 싶을 때
        - 갈등의 상대방과 대등한 힘을 가지고 동일한 목표를 추구할 때
        - 시간 압박이 있는 상황에서 무난한 결론이 필요할 때
    3) 주의 사항
        - 협력 or 경쟁으로 전환하기 위한 잠복 단계
<br/>
<br/>

## 📅 2025.01.15.WED
### PM 특강
1. 어떤 프로젝트 팀이 월등한 성과를 이루는가?
    1) 구조 및 명확성: 분명한 목표와 역할
    2) 상호 의존성: 서로 역량을 신뢰할 수 있는 구성원 선발
    3) 일의 의미: 자신의 일에 대하여 개인적 의미를 부여
    4) 일의 영향: 프로젝트가 중요하고 변화를 만드는 것이라는 믿음
    5) 심리적 안전감: 약점을 공개해도 불이익 받지 않는 팀 분위기

2. 프로젝트 종료 단계에서 팀장이 가져야 할 마음가짐
    1) 리더로서의 책임감
    2) 품질에 대한 직접적인 확인
    3) 종료는 프로젝트 안에서 새로운 프로젝트 시작
<br/>
<br/>

## 📅 2025.01.16.THU
### 일의 효율성을 높이는 방법
1. GTD
2. 일의 중요도 결정
3. 만트라트
4. 뽀모도로
    - 1 cycle: 25분 집중 + 5분 휴식
    - 4 cycle 수행하면 길게 휴식
5. 타임박싱
6. 타임 블로킹
    - 나만의 시간을 확보해놓기
7. PARA method
    - project, area, resource, archive
8. 제텔카스텐 (메모상자)
    - 임시적, 영구적인 메모를 수시로 작성
    - 연관된 메모들을 index 카드로 관리
    - 연관된 메모들끼리도 서로 가리키도록 기록
<br/>
<br/>

## 📅 2025.01.17.FRI
### MediaRecorder의 데이터 저장 방식
- `MediaRecorder`는 녹화를 시작할 때 `start(timeslice)`를 설정하면 해당 `timeslice(ms)`마다 `ondataavailable` 이벤트를 통해 Blob 데이터를 생성한다.
- `ondataavailable에서` 받은 `event.data`를 IndexedDB에 저장하면, 녹화된 비디오를 저장 및 재생할 수 있다.

### IndexedDB 트랜잭션 관리
- IndexedDB에 데이터를 저장하려면 `transaction`을 생성하고, 그 안에서 데이터를 `add()`해야 한다.
- `TransactionInactiveError`는 트랜잭션이 닫힌 후 데이터를 저장하려고 할 때 발생한다.

### IndexedDB에서 Blob 데이터를 올바르게 복원하는 방법
- IndexedDB에서 데이터를 가져올 때, Blob을 저장하면 MIME 타입 정보가 손실될 수 있다.
- Blob을 `arrayBuffer()`로 변환해 저장하고, 다시 Blob으로 복원해야 한다.

### MediaRecorder의 중복 실행 방지
- `mediaRecorder.stop()`을 `ondataavailable` 내부에서 호출하면 새로운 녹화가 시작될 때마다 중복 실행이 발생할 수 있다.
- `startRecording()` 내에서 `mediaRecorder.start(5000)`을 한 번만 실행해야 한다.
<br/>
<br/>

## 📅 2025.01.20.MON
### Git Branch 전략
#### 1. Git Flow
- `main` 브랜치는 안정적인 배포 버전을 유지하고, `develop` 브랜치에서 개발을 진행한다.
- `feature/{기능명}` 브랜치를 생성해 기능 개발 후, `develop`에 머지한다.
- `release/{버전명}` 브랜치를 만들어 QA 및 테스트를 진행하고, 검증이 끝나면 `main`과 `develop`에 병합한다.
- `hotfix/{버그명}` 브랜치는 배포된 `main`에서 긴급 버그 수정 시 사용된다.

#### 2. GitHub Flow
- `main` 브랜치에서 직접 `feature/{기능명}` 브랜치를 생성하고, PR(Pull Request)을 통해 병합한다.
- CI/CD 환경과 잘 맞으며, 빠른 개발 주기에 적합하다.
- `hotfix` 브랜치는 필요 시 `main`에서 직접 생성하여 버그를 수정한 후 배포한다.

#### 3. GitLab Flow
- `main` 브랜치는 항상 배포 가능한 상태를 유지하며, `feature` 브랜치는 필요할 때 생성한다.
- `production`, `staging` 브랜치를 추가하여 배포 환경별 코드 분리를 지원한다.
- `environment` 기반으로 브랜치를 나누어, 특정 환경에서만 테스트할 수 있도록 한다.

#### 4. Trunk-Based Development
- `main` 브랜치에서 직접 개발하며, 작은 단위로 빈번한 병합을 수행한다.
- 브랜치 생성을 최소화하고, `feature flag`를 활용해 미완성 기능을 비활성화한 채 배포할 수 있다.
- 대규모 협업 프로젝트에서 CI/CD를 활용한 지속적인 배포에 적합하다.
<br/>
<br/>

## 📅 2025.01.21.TUE
### JavaScript 및 TypeScript의 컴파일 동작 과정
- JavaScript는 인터프리터 언어이지만, V8 엔진 등에서 Just-In-Time(JIT) 컴파일을 통해 실행 속도를 최적화한다.
- TypeScript는 정적 타입을 제공하며, `tsc`(TypeScript Compiler)를 사용해 JavaScript 코드로 변환된다.
- `tsc`는 코드의 타입 검사를 수행한 후, 설정된 `target` 버전에 맞게 ES5, ES6 등으로 변환한다.
- TypeScript의 `strict` 옵션을 활성화하면 더 엄격한 타입 검사를 적용할 수 있다.

### Babel과 SWC의 비교
- `Babel`과 `SWC`는 모두 JavaScript/TypeScript 코드를 트랜스파일하는 도구지만, 동작 방식과 성능이 다르다.
- `Babel`은 AST(Abstract Syntax Tree) 기반으로 변환하며, 플러그인을 활용해 다양한 변환 작업을 수행할 수 있다.
- `SWC(Speedy Web Compiler)`는 Rust 기반으로 작성되어 있으며, Babel보다 빠른 변환 속도를 제공한다.
- `SWC`는 멀티스레딩을 활용하여 성능을 극대화하며, 최근 Next.js에서 기본 트랜스파일러로 채택되었다.
- `Babel`은 플러그인 확장성이 뛰어나며, `@babel/preset-env`를 활용하면 브라우저 호환성을 조정할 수 있다.
- `SWC`는 설정이 간단하며, 특히 대규모 프로젝트에서 빌드 속도를 크게 개선할 수 있다.