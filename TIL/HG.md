# 1월 셋째 줄 TIL (Today I Learned)

## 📅 날짜

### 2025-01-13

## ✏️ 오늘 한 일

- JIRA 에 대한 간단한 설명
- 기존 프로젝트의 디벨롭할 것인지, 새 프로젝트를 다시 기획할 것인지 논의.
  - 기존 프로젝트를 일단 디벨롭하는 방향으로 의견 수렴.
- 피그마: 기본 와이어프레임 제작.

## 📅 날짜

### 2025-01-14

## ✏️ 오늘 한 일

- 기획 컨펌 전 전체 방향 정돈
- 기획 컨펌
- 기획에 대한 방향성 재설립
- 아디이어 브레인스토밍

## 배운 점

- 기획에 대한 방향성

  - 타켓하려는 대상을 구체화.

  - WebRTC의 기능을 적극적으로 활용해도 괜찮다.

  - 폐기 아이디어 재고찰

  - MVP가 커야 한다. 규모를 채우기 위해 어거지 덕지덕지는 별로다.

  - 기존 서비스에 비해 차별성을 가져갈 수 있어야

- 새로운 아이디어 모색법: **브레인라이팅(Brainwriting)**

### 브레인라이팅(Brainwriting)

브레인라이팅은 브레인스토밍의 단점을 보완하기 위해 개발된 아이디어 발상법입니다. 이 기법은 참가자들이 주제에 대한 의견을 말하는 대신 종이에 적는 방식을 사용합니다.

**진행 방법**

1. 주제 또는 카테고리 선정
2. 참가자들이 일정 시간 동안 아이디어를 종이에 기록
3. 시간 종료 후 종이를 옆 사람에게 전달
4. 새로운 주제나 카테고리로 변경
5. 과정 반복
6. 모든 과정 종료 후 아이디어 공유 및 토론

### 장점

- **평등한 참여**: 모든 참가자가 동등하게 아이디어를 제시할 수 있음
- **균형 잡힌 의견 수렴**: 특정 인물에게 대화의 주도권이 돌아가는 것을 방지
- **소극적인 참가자 배려**: 말하기를 꺼리는 사람들도 자유롭게 의견을 낼 수 있음

브레인라이팅은 팀의 창의성을 극대화하고 다양한 아이디어를 체계적으로 정리하는 데 효과적인 방법입니다.

## 📅 날짜

### 2025-01-15

## ✏️ 오늘 배운 점

### GIT 특강

- GIT이 왜 필요한가?

  - 이력관리: 모든 기록은 저장된다

  - 분산버전 관리: 로컬 & 원격 저장소 활용과 협업

  - 협업 효율성: 여러 사람이 동시에 충돌 없이 작업이 가능하다

- GIT 기본 개념

  - 저장소: 코드의 역사와 현재를 담은 공간

  - 커밋: 변화의 순간을 포착하는 스냅샷

    - 고려사항:

      - 시점: 논리적으로 완결된 작업 단위

      - 횟수: 작은 단위로 자주 커밋

    - 구성 :

      - commit ID

      - 작성자 정보

      - 커밋 메세지

  - 브랜치: 아이디어를 실험하고 구현하는 독립적인 공간

  - 병합

- Git 사용 시 주의점:

  1. 커밋 메세지 작성 규칙: 명확하고 일관적인 메세지 작성이 중요

     - git config

     - conventional commits 참고하기

     - 본문이 선택이긴 하지만... 써 주세요

  2. 브랜치 전략: 명확한 브랜치 구조는 작업속도를 높이고 충돌을 최소화

     - 브랜치 과다 생성 시 관리 / 작업 복잡

     - `브랜치 전략`: git flow / gitlab flow / github flow

  - 효율적인 팀 협업 개발을 위해 커밋 규칙과 브랜치 전략 꼭 정하자

## 📅 날짜

### 2025-01-16

## ✏️ 오늘 배운 점

### 1. 생성형 Ai, 내 동료가 되어라

1. ChatGPT

- GPT-4o
- o1: 시간은 많이 드나 복잡한거 가능
- o1 미니

2. 이미지 생성

- DALL-E3
- Stable Diffusion: 무료지만 서버는 필요해요
- Mid journey: 프롬프트 기반이거나, 주어진 이미지 기반이거나

3. 노래 AI: Suno, Stable audio

   - 영상 포트폴리오

4. Claude: 월 구독제 but 20만 토큰

- 많은 용량 사용시 굳
- 개발 능력 특화
- `Artifacts 기능` -> 테트리스 게임
  - Remix Artifacts

5. 이미지 생성 AI `Editting`

- upscaling : 깨지지 않게 2배 3배 4배
- outpainting
- inpainting: 누끼, 객체 삭제
- 마스킹 따기
- Merging face -> 노비타 AI

6. 비디오 생성 AI

- KLING
- SORA

7. Gemini AI

- 아이언맨 자비스 같네 "저 조각상 뭐야?"
- PM 역할
- 게임도 만듦
- 로봇공학과의 융합

결론:  
**AI AGENT**

- 과거에는 텍스트, 이미지, 음악을 출력했으나,
- 이제 문제 해결과 복잡한 작업 실행에 초점을 둔다.

---

### 2. 개인 생산성 향상 기법

- 할 일, 공부할 것, 정보 너무 많다... ㅠㅠ

- 단순한 TODO 리스트보다 나은 방법은 없나?

1. **GTD**

- Get Things Done
- 할 일을 특정 알고리즘으로 분류
- is it actionable?
  - 버리거나 / 미루거나 / 위임해라
  - 이 기능이 Powerful
- 실제 가능한 업무에 대한 것만 집중하게끔 해줌.
- 이 기반으로 Todolist를 만드는 분들도 있음.
- `과감하게 버리는 / 위임하는` -> 부하 완화

2. **아이젠하워 매트릭스**

- `사분면`으로 나눔
- 긴박한가? 느긋한가?
- 중요한가? 안중요한가?
  - 긴박, 중요 : 해
  - 느긋, 중요: 스케쥴링
  - 느긋, 안중요: 삭제
  - 긴박, 안중요: 위임

3. **만트라트**

- 오타니
- 스도쿠같은데 `9분면`

4. **뽀모도로**

- `타이머 25분`

  5.**타임박싱**

- 업무는 주어진 시간만큼 증가하기 마련
- `일정 시간` 내에 특정 작업을 끝내겠다는 목표를 세우는 것
- 발등에 불 떨어뜨리기

6. **타임 블로킹**

- 자기 시간 확보
- `코어 타임`

7. **PARA METHOD**

- `Project`

  목표와 데드라인이 명확한 일들에 관한 노트가 여기에 속한다.  
   예를 들면, '이사하기', '블로그 글 작성', '이직', '여행 계획' 등이 있다.

- `Area`
  특정한 데드라인은 없지만 지속적으로 관심을 가져야 하는 영역이다.  
   '건강 관리', '재무 관리', '집안 일', '차량 유지', '가족 관계' 등의 주제가 여기에 해당된다.

- `Resource`
  특정 주제에 대한 관심사나 자료를 모아둔 카테고리이다.

- `Archive`
  더 이상 필요하지 않은, 완료된 프로젝트나 오래된 노트를 보관하는 곳이다.

8. **재텔카스텐**

- 독일어로 메모 상자

1. 임시적, 영구적 메모를 수시로 작성
2. 연관된 메모들을 index 카드로 관리
3. 연관된 메모들끼리도 사로 가리키게 기록

---

## 📅 날짜

### 2025-01-17

### ✏️ 오늘 한 거:

### 1. 프로젝트와 기술, 포폴

- 소크라테스

  - 산파술 (문답법)
    - 질문에 질문이 꼬리를 물어서 ...

- 면접관이 포트폴리오 볼 때에도 마찬가지이다.

  - 이 기술 왜 씀?
    - 왜 좋음?
      - 왜 빠름? ...

- 어떤 기술을 쓸 때 당위성이 있어야 함.

- FAQ1. 프로젝트가 많아야 할까요?

  - 좋을 수 있는 이유: 그 팀의 JD에 딱 맞는 포트폴리오를 제출할 수 있어서
  - 제출을 할 때에는 그 팀에 맞는 거 한 두개만 있어도 괜찮아요

- FAQ2. 프로젝트가 화려해야 할까요?

  - 새로운 기술...
  - 네니오?
    - 공채라면, 서류에서 필터링 안 되는게 중요할지도
    - 팀별 모집이라면, 그 팀에 맞는 기술 스택 혹은 비슷한 경험이 중요

- Base가 되는 포트폴리오 하나를 두고, 지원할때마다 조금씩 튜닝

### 2. 와이어프레임 제작

### 3. 유스케이스 설정

### 4. Media Recorder API 문서 공부

- IndexedDB key characteristics and basic terminology

---

## 📅 날짜

### 2025-01-21

### ✏️ 오늘 한 거:

# TIL: TypeScript, SWC, Axios, and Build Tools

## 1. TypeScript를 배워야 하는 이유

TypeScript를 배워야 하는 주요 이유는 다음과 같습니다:

1. **타입 안정성**: TypeScript는 정적 타입 검사를 통해 많은 버그를 사전에 방지할 수 있습니다. 연구에 따르면 일반적인 버그의 15%를 컴파일 단계에서 잡아낼 수 있다고 합니다.

2. **개발 생산성 향상**: 강력한 자동 완성과 인텔리센스 기능을 제공하여 개발 속도를 높이고 실수를 줄일 수 있습니다.

3. **코드 가독성과 유지보수성**: 타입 정의를 통해 코드의 의도를 명확히 표현할 수 있어 협업과 유지보수가 용이해집니다.

4. **대규모 프로젝트에 적합**: 복잡한 프로젝트에서 타입 시스템을 통해 코드의 구조를 더 잘 이해하고 관리할 수 있습니다.

5. **커뮤니티와 생태계**: TypeScript는 큰 커뮤니티와 풍부한 라이브러리 생태계를 가지고 있어 다양한 지원을 받을 수 있습니다.

## 2. SWC vs. Babel

SWC(Speedy Web Compiler)는 Rust로 작성된 빠른 JavaScript/TypeScript 컴파일러입니다. Babel과 비교하면 다음과 같은 특징이 있습니다:

1. **속도**: SWC는 Babel보다 훨씬 빠릅니다. 단일 스레드에서 약 20배, 멀티코어 환경에서 약 70배 빠르다고 알려져 있습니다.

2. **기능**: SWC는 Babel과 유사한 기능을 제공하지만, 일부 고급 플러그인은 지원하지 않을 수 있습니다.

3. **사용 편의성**: SWC는 설정이 간단하고 대부분의 경우 추가 구성 없이 사용할 수 있습니다.

4. **생태계**: Babel은 오랜 기간 사용되어 왔기 때문에 더 많은 플러그인과 커뮤니티 지원을 받고 있습니다.

## 3. CRA vs. Vite

Create React App(CRA)와 Vite는 React 프로젝트를 시작하는 데 사용되는 도구입니다. 주요 차이점은 다음과 같습니다:

1. **성능**: Vite가 CRA보다 훨씬 빠른 개발 서버 시작 및 빌드 시간을 제공합니다.

2. **구성**: CRA는 설정이 거의 필요 없지만, Vite는 더 유연한 구성을 제공합니다.

3. **번들링**: CRA는 Webpack을 사용하고, Vite는 Rollup과 esbuild를 사용합니다.

4. **생태계**: CRA는 더 오래되고 안정적인 생태계를 가지고 있지만, Vite는 빠르게 성장하고 있습니다.

5. **최신 기술 지원**: Vite는 ES 모듈을 네이티브로 지원하여 더 현대적인 개발 경험을 제공합니다.

결론적으로, 새로운 프로젝트에는 Vite를 사용하는 것이 성능과 개발 경험 측면에서 유리할 수 있습니다.

## 📅 날짜

### 2025-01-22

## ✏️ 오늘 배운 점

### 1. Commit Message Convention (Style) Guide

커밋 메시지 컨벤션은 프로젝트의 히스토리를 일관되게 관리하고 협업을 원활하게 하는 데 중요합니다. 주요 구성 요소는 다음과 같습니다:

1. **Type**: 커밋의 목적이나 내용을 나타냅니다.

   - feat: 새로운 기능 추가
   - fix: 버그 수정
   - docs: 문서 수정
   - style: 코드 포맷팅, 세미콜론 누락 등
   - refactor: 코드 리팩토링
   - test: 테스트 코드 추가
   - `chore`: 빌드 작업, 패키지 매니저 설정 등

2. **Scope**: 커밋이 영향을 미치는 범위를 나타냅니다 (선택사항).

3. **Subject**: 변경사항에 대한 간결한 설명입니다.

4. **Body**: 변경사항에 대한 자세한 설명입니다 (선택사항).

5. **Footer**: 주요 변경사항이나 Breaking Changes를 명시합니다 (선택사항).

예시:

```
feat(user): 사용자 로그인 기능 추가

- 이메일과 비밀번호를 이용한 로그인 구현
- JWT 토큰 발급 및 저장 로직 추가

Closes #123
```

이러한 컨벤션을 따르면 코드 리뷰, 버전 관리, 릴리즈 노트 작성 등이 더욱 효율적으로 이루어질 수 있습니다.

### 2. [React] Prop Drilling 이란 무엇이고, 어떻게 해결할 수 있을까?

Prop Drilling은 React 애플리케이션에서 `상위 컴포넌트의 state를 여러 단계의 하위 컴포넌트로 전달해야 할 때 발생`하는 문제입니다. 이는 코드의 가독성을 떨어뜨리고 유지보수를 어렵게 만들 수 있습니다.

해결 방법:

1. `**Context API**`: React의 내장 기능으로, 전역 상태를 관리하고 필요한 컴포넌트에 직접 제공할 수 있습니다.

2. `**상태 관리 라이브러리**`: Redux, MobX, Recoil 등을 사용하여 전역 상태를 효율적으로 관리할 수 있습니다.

3. **컴포넌트 구조 재설계**: 상태를 사용하는 컴포넌트들을 가능한 한 가까이 배치하여 prop drilling을 최소화합니다.

4. **Render Props 패턴**: 컴포넌트의 렌더링 로직을 props로 전달하여 재사용성을 높이고 prop drilling을 줄일 수 있습니다.

5. **Hooks 사용**: Custom Hooks를 만들어 상태 로직을 재사용하고 컴포넌트 간 공유를 쉽게 할 수 있습니다.

## 불필요한 렌더링 최소화

Zustand는 상태 변화에 따른 불필요한 컴포넌트 렌더링을 효과적으로 최소화합니다. 이는 특히 대규모 애플리케이션에서 성능을 크게 향상시키는 중요한 특징입니다

### Zustand의 렌더링 최적화 방식

1. **선택적 구독**: Zustand는 컴포넌트가 실제로 사용하는 상태 부분만 구독하도록 합니다. 이를 통해 관련 없는 상태 변경으로 인한 불필요한 리렌더링을 방지합니다[2].

2. **얕은 비교**: Zustand는 기본적으로 얕은 비교를 사용하여 상태 변경을 감지합니다. 이는 불필요한 리렌더링을 줄이는 데 도움이 됩니다[14].

3. **성능 최적화된 구조**: Zustand는 내부적으로 Proxy 기반 시스템을 사용하여 상태 변경을 추적하고, 필요한 경우에만 컴포넌트를 리렌더링합니다[8].

### useStore 훅의 활용

useStore 훅을 사용하면 상태 업데이트가 UI 렌더링을 일으키지 않도록 세밀하게 제어할 수 있습니다:

```javascript
const bears = useStore(
  (state) => state.bears,
  (oldBears, newBears) => oldBears === newBears
);
```

이 방식을 통해 특정 조건에서만 리렌더링이 발생하도록 설정할 수 있습니다[15].

### Context API와의 비교

Context API를 사용할 때 흔히 겪는 리렌더링 문제와 달리, Zustand는 이러한 문제를 효과적으로 해결합니다. Context API는 상태가 변경될 때마다 해당 Context를 사용하는 모든 컴포넌트가 리렌더링되는 반면, Zustand는 실제로 변경된 상태를 사용하는 컴포넌트만 리렌더링합니다[19][26].

### 대규모 애플리케이션에서의 이점

복잡하고 큰 규모의 애플리케이션에서 Zustand의 이러한 특성은 특히 유용합니다. 불필요한 리렌더링을 줄임으로써 애플리케이션의 전반적인 성능과 반응성을 크게 향상시킬 수 있습니다[7][23].

Context API를 사용했던 프로젝트에서 리렌더링 관련 문제로 어려움을 겪었다면, Zustand로의 전환은 이러한 문제를 해결하는 데 큰 도움이 될 수 있습니다. Zustand의 효율적인 상태 관리와 렌더링 최적화는 개발자들에게 상당한 이점을 제공합니다[24][37].

## 📅 날짜

### 2025-01-23

## ✏️ 오늘 배운 점

### 1. 코드 리뷰 및 커밋

#### 코드 리뷰란

코드 리뷰는 개발자들이 서로의 코드를 검토하고 피드백을 주는 과정입니다. 이는 코드 품질 향상과 팀 협업 강화를 위한 중요한 실무입니다.

#### 기대효과

- 버그 조기 발견 및 수정
- 코드 품질 향상
- 지식 공유 및 팀 역량 강화
- 일관된 코딩 스타일 유지

#### 코딩 컨벤션

팀 내에서 일관된 코드 작성을 위한 규칙으로, 가독성과 유지보수성을 높입니다.

#### 좋은 코드란

- 가독성이 높고 이해하기 쉬운 코드
- 효율적이고 성능이 좋은 코드
- 유지보수가 용이한 코드
- 확장성이 있는 코드

#### 코드 리뷰의 필요성

- 코드 품질 보장
- 팀 내 지식 공유
- 일관성 있는 코드베이스 유지
- 개발자 간 상호 학습

#### 코드 리뷰 참여자의 자세

1. Reviewer로서:

   - 객관적이고 건설적인 피드백 제공
   - 코드의 장단점을 균형있게 평가
   - 개선 제안 시 명확한 이유 제시

2. Reviewee로서:

   - 열린 마음으로 피드백 수용
   - 필요시 추가 설명이나 컨텍스트 제공
   - 개선 제안에 대해 적극적으로 대응

3. 팀원으로서:

   - 상호 존중과 신뢰 구축
   - 지속적인 학습과 개선 노력
   - 팀의 코딩 표준 준수

4. 개발자로서:
   - 최신 기술 트렌드 파악
   - 코드 품질에 대한 높은 기준 유지
   - 지속적인 자기 개발

### 2. Design Convention

피그마를 이용한 데스크톱 및 웹 애플리케이션 디자인 시 준수해야 할 규약:

1. 간격 및 크기:

   - 모든 간격과 글꼴 크기는 4px의 배수로 설정
   - 이는 일관된 레이아웃과 가독성 향상에 도움

2. 색상 체계:

   - 일관된 색상 팔레트 사용
   - 주요 색상, 보조 색상, 강조 색상 등을 명확히 정의

3. 타이포그래피:

   - 제목, 본문, 버튼 등 각 요소별 일관된 폰트 스타일 적용
   - 글꼴 크기의 계층 구조 설정 (예: 제목 24px, 부제목 18px, 본문 16px)

4. 그리드 시스템:

   - 12칼럼 또는 8칼럼 그리드 시스템 활용
   - 반응형 디자인을 위한 브레이크포인트 설정

5. 컴포넌트 디자인:

   - 재사용 가능한 UI 컴포넌트 제작
   - 버튼, 입력 필드, 카드 등의 일관된 스타일 가이드 준수

6. 아이콘 및 이미지:

   - 일관된 스타일의 아이콘 세트 사용
   - 이미지 크기 및 비율 표준화

7. 상호작용 디자인:

   - 호버, 클릭, 포커스 등의 상태에 대한 일관된 시각적 피드백 제공

8. 접근성:
   - 색상 대비, 글꼴 크기 등 WCAG 가이드라인 준수

이러한 디자인 컨벤션을 준수함으로써 일관성 있고 전문적인 사용자 인터페이스를 구현할 수 있습니다.

## 📅 날짜

### 2025-01-24

## ✏️ 오늘 배운 점

### 1. 애자일 개발

#### 1-1. 애자일 개발이란

- 스프린트라는 일정주기를 통해 설계, 개발, 테스트를 반복해 프로젝트를 완성하는 작업
- 고객과의 즉각적인 소통과 피드백을 통해 요구사항을 신속하게 반영할 수 있음

#### 1-2. 등장배경

- 폭포수 개발론
- 폭포수 개발론과의 차이
- 폭포수 개발론은 무조건 나쁜가?

#### 1-3. 애자일 개발의 장단점

- 장점: 빠른 피드백, 빠른 소통, 제품을 빠르게 출시
- 단점: 반복적인 작업으로 번아웃이 쉽게 옴

#### 1-4. 애자일 프레임워크

- MVP
- SPRINT
- 스크럼
- TDD
- Copilot
- Devops

### 2. 톡식하지 않는 개발자 되기

#### 무의식이 결정을 먼저 내리고 의식이 한다.

- FACT는 사실 우리의 느낌, 감일 수 있어요

#### 팩트에 팩트만 있나?

- 팩트와 묘하게 평가가 들어갈 수 있음.
- "니 제대로 이해한거 맞음? 그건…"

#### 톤 앤 매너

- 건설적인 피드백도 아프긴 한데…
- 근데 안 아프게 얘기할 수 있어요

##### I-statement

- 나 전달법

##### 공통의 목표 환기하기

- "우리 팀이 X를 하고 싶다는 걸 생각했을 때," 이렇게 하는 게 더 좋겠어

##### 상대의 입장 확인하기

- "아마 이러이러한 상황 때문에 이렇게 한 것 같은데," 이렇게 하는 게 더 좋겠어.

#### 그 외 버려야 할 태도

##### 사무적/기계적으로 말하는 것

- "안녕 패트, 네 사촌이 죽었다."
  - 직선적이고 사무적인 말투가 효율적일지라도 궁극적으로 팀 분위기를 헤쳐요
- 타인의 감정을 배려한 말투를 씁시다
  - 기계적인 말투보다 **우리 모두의 생산성**을 증대할 수 있어요

###### 그럼 어케 해 : 칭찬

- 상대가 잘한 부분을 크게 말해줄 수 있는 배포

##### 습관적 비관

- "그냥 안 될 것 같은데요"
  - bias일 수 있어요
- **실패 염려에 대한 대안 제시**까지 있어야 좋아요

##### 거들먹, 빈정거림

- "A는 공부 참 많이 하셨네요 ^^, 근데 그건 옛날거에요 ^^"
  - 상대의 노력을 뭉뚱그려 무시하는 거에요

##### 수동적 공격성

- 적개심, 불만을 품은 대상에게 **간접적인** 방법을 통해 불편하게 만드는 행동 양식
- "아 정말 괜찮아" (한숨을 엄청나게 쉬며) 딩딩딩딩딩
- 기가 세거나 재치있는게 아니에요 ㅠㅠ
  - 투명하게 소통하지 못하는 거에요.
