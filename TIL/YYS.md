# 📘 TIL (Today I Learned)

## 📅 날짜

- 2025-01-13

---

## ✏️ 배운 것

- Jira는 프로젝트 및 이슈 관리를 위한 도구로, 태스크 생성, 우선순위 설정, 워크플로우 트래킹에 최적화되어 있다.
- 보드(칸반/스크럼)를 활용해 팀의 작업 현황을 시각적으로 파악 가능하다.
- 자동화 규칙 설정으로 반복 작업을 줄이고 효율성을 극대화할 수 있다.

---

## 📅 날짜

- 2025-01-14

---

## ✏️ 배운 것

- 기획 단계에서는 MVP설정이 중요하고, 결국 타겟이 누구인지, 어떤 문제를 해결할 수 있는지 명확히 하는것이 중요하다는 것을 깨달았다.
- 정해진 틀에서 벗어나 새로운 아이디어를 브레인스토밍 하는 과정의 필요성을 느꼈다.
- 키워드 중심의 브레인스토밍이 효과적이라는 것을 깨달았다.

---

## 📅 날짜

- 2025-01-15

---

## ✏️ 배운 것

- 개발을 시작하기 전에 브랜치 전략은 어떤 방법을 사용할 것인지, 커밋 규칙을 어떻게 정할 것인지 결정하는 것이 정말 중요하다라는 것을 깨달았다.
- 브랜치 전략에는 git flow, github flow, gitlab flow가 있고 각각의 전략마다 특징을 알게 되었다.
- Git Flow: 브랜치를 명확히 분리하여 기능 개발, 릴리스, 핫픽스를 관리하는 전통적인 워크플로우 전략.
- GitHub Flow: 메인 브랜치를 중심으로 단순화된 브랜치 전략으로, 항상 배포 가능한 상태를 유지하며 풀 리퀘스트 기반으로 작업.
- GitLab Flow: CI/CD와 통합된 워크플로우로, 환경(예: 개발, 스테이징, 프로덕션)과 릴리스 관리를 중점으로 한 전략.

---

## 📅 날짜

- 2025-01-16

---

## ✏️ 배운 것

- 지라를 활용하여 에픽, 스토리, 테스크를 등록하는 방법과 스프린트 작성법을 알게 되었다.
- 할 일을 정리하고 효율적으로 작업을 수행하기 위한 기법들에 대해 알아보았다.

#### GTD (Getting Things Done) : 정리의 기술

- 할 일을 체계적으로 분류하고 처리하는 데 초점.

#### 아이젠하워 매트릭스 : 우선순위 정리

- 중요도와 긴급성에 따라 작업을 4가지로 구분.

#### 만트라트 (Mantra + Chart) : 훈련과 시각화

- 목표 달성을 위한 반복적 훈련과 차트 기반 관리.(ex : 오타니의 훈련 트레이닝)

#### 포모도로 기법 : 시간 집중 관리

- 25분 집중 + 5분 휴식을 통해 효율적인 작업.

#### 타임박싱 : 데드라인 설정

- 정해진 시간 안에 특정 작업을 끝내는 방법.

#### 타임 블로킹 : 시간 블록 활용

- 특정 시간대를 집중 작업 시간으로 예약.

#### PARA Method : 정보 분류 관리

- 프로젝트, 관심사, 자료, 아카이브로 체계화.

#### 제텔카스텐 : 아이디어 연결

- 독립된 메모를 상호 연결해 창의적 사고를 촉진.

---

## 📅 날짜

- 2025-01-17

---

## ✏️ 배운 것

- 소크라테스의 문답법 : 상대방에게 질문을 던져 진리를 낳도록 돕는 방법
- 프로젝트가 많아야하나? 그건 아니다. Job Description를 확인하고 그에 맞는 프로젝트가 필요하다.
- 프로젝트가 화려해야할까? 반반. 화려함의 기준(새로운것?, 최신기술?)
- 채용시장 트렌드(대규모 공채에서는 눈에띄는게 좋다. 팀별 모집이라면 그 팀에 맞는 기술 스택 or 비슷한 경험이 중요)
- 베이스가 되는 포폴을 하나 만들어 놓고, 지원할때마다 조금씩 튜닝
- 오늘은 팀원들과 유스 케이스를 만들고, 대략적인 API 명세서를 설계하였다.
- WebRTC 개념에 대해 배웠고, 적용 방법에 대해 주말간 열심히 공부해 볼 생각이다.

## 📅 날짜

- 2025-01-20

---

## ✏️ 배운 것

## 인증 및 보안 개념 정리

### 1. 인증 (Authentication)

- 사용자가 누구인지 확인하는 과정.
- 아이디, 비밀번호, 생체 인식 등을 통해 사용자의 신원을 검증.
- 예: 로그인 시 아이디/비밀번호 확인.

### 2. 인가 (Authorization)

- 사용자가 특정 리소스에 접근할 수 있는 권한을 부여하는 과정.
- 권한(role)에 따라 접근 가능 여부 결정.
- 예: 관리자만 특정 페이지에 접근 가능.

### 3. Session Storage

- 웹 브라우저의 메모리에 일시적으로 데이터를 저장하는 방식.
- 세션이 종료되면 데이터가 사라짐.
- 주로 로그인 상태나 임시 데이터를 저장하는 데 사용.

### 4. Cookie

- 클라이언트(브라우저)에서 데이터를 저장하는 작은 파일.
- 상태 유지(세션, 인증 정보)를 위해 서버가 클라이언트에게 전송.
- 주요 속성:
    - `HttpOnly`: JavaScript 접근 차단(XSS 방지)
    - `Secure`: HTTPS 환경에서만 전송
    - `SameSite`: 크로스사이트 요청 제한(CSRF 방지)

### 5. JWT (JSON Web Token)

- 사용자 인증 및 정보 전달을 위한 토큰 기반 인증 방식.
- 구성 요소: `Header`.`Payload`.`Signature`
- 특징:
    - 무상태(stateless) 인증 가능.
    - 클라이언트 측에서 인증 정보 보유 가능.
    - 서버 부담 감소.

### 6. Access Token

- 사용자가 인증된 후 API 요청 시 권한을 검증하는 데 사용되는 토큰.
- 유효 기간이 짧고, 요청마다 헤더에 포함되어 전송.
- 리소스 서버가 이를 기반으로 요청을 승인하거나 거부.

### 7. Refresh Token

- Access Token이 만료되었을 때 새로운 Access Token을 발급받기 위한 토큰.
- 일반적으로 서버 측에서 저장되며, 유효 기간이 길다.
- Access Token이 탈취되어도 피해를 최소화하기 위해 사용.

### 8. Spring Security

- Spring 프레임워크의 보안 모듈로 인증 및 인가 기능 제공.
- 다양한 보안 기능 제공: 로그인, CSRF 방어, 세션 관리, OAuth2 지원.
- 주요 구성 요소:
    - `AuthenticationManager`
    - `SecurityFilterChain`
    - `UserDetailsService`

### 9. OAuth 2.0

- 권한 위임을 위한 표준 프로토콜.
- 사용자가 특정 리소스에 대한 액세스를 제3자 애플리케이션에 위임할 수 있도록 설계.
- 주요 흐름:
    1. 사용자가 클라이언트 애플리케이션에 로그인 요청.
    2. 클라이언트는 권한 코드를 받기 위해 인증 서버로 리디렉션.
    3. 인증 서버는 권한 코드를 제공.
    4. 클라이언트는 권한 코드를 사용해 액세스 토큰을 요청.
    5. 액세스 토큰을 사용하여 리소스 서버에 접근.

### 10. HttpOnly

- 쿠키의 속성으로, JavaScript에서 접근하지 못하도록 제한.
- 보안 강화를 위해 사용되며, XSS 공격 방지에 효과적.

---

## OAuth 주요 구성 요소

1. **Resource Owner (사용자)**: 실제 리소스(데이터)를 소유한 사용자.
2. **Client (클라이언트 애플리케이션)**: 사용자의 리소스를 접근하려는 외부 플랫폼.
3. **Authorization Server (인증 서버)**: 클라이언트가 사용자 리소스를 사용하도록 인증을 처리.
4. **Resource Server (리소스 서버)**: 사용자의 데이터를 제공하는 서버.

---

## 총정리: OAuth 2.0과 HttpOnly 쿠키 기반 인증 흐름

1. **사용자가 웹사이트에 로그인 요청(인증, Authentication).**
2. 클라이언트(예: 웹사이트)는 OAuth 2.0을 통해 인증 서버(Authorization Server)로 리디렉션.
3. 사용자가 로그인 후, 인증 서버는 클라이언트에 인증 코드(Authorization Code)를 제공.
4. 클라이언트는 인증 코드를 백엔드 서버로 전송하고, 백엔드 서버는 이를 이용해 인증 서버에 액세스 토큰과 리프레시 토큰을 요청.
5. 서버는 Access Token을 **HttpOnly 쿠키**에 저장하여 클라이언트가 직접 접근할 수 없도록 보호.
6. 클라이언트는 이후 API 요청 시 브라우저에서 자동으로 쿠키를 전송하고, 서버는 이를 검증하여 접근을 허용.
7. Access Token이 만료되면 클라이언트는 Refresh Token을 사용하여 새로운 Access Token을 발급받음.
8. 리소스 서버(Resource Server)는 Access Token을 검증하고 사용자 리소스를 제공.
9. Spring Security는 이러한 흐름을 관리하며, OAuth 2.0 프로토콜과 HttpOnly 쿠키를 통해 보안 강화.

---

## 📅 날짜

- 2025-01-21

---

## ✏️ 배운 것

- Spring Security는 스프링 애플리케이션에서 인증(Authentication)과 인가(Authorization)을 제공하는 보안 프레임워크이다.
- OAuth 2.0은 사용자의 자격 증명을 외부 인증 서버(예: 카카오, 구글)에 위임하여 보안 강화를 지원하는 인증 프로토콜이다.
- Spring Security는 OAuth 2.0과 통합하여 소셜 로그인 기능을 쉽게 구현할 수 있으며, 사용자 정보를 보호하기 위해 JWT 및 HttpOnly 쿠키를 활용할 수 있다.
- OAuth 인증 후 서버에서 발급받은 액세스 토큰을 활용하여 API 요청을 수행하고, 리프레시 토큰으로 만료 시 갱신을 관리할 수 있다.
- 보안 강화를 위해 CORS 설정, CSRF 방어, 권한 기반 접근 제어 및 로깅을 함께 설정하여 보다 안전한 애플리케이션을 구축할 수 있다.

## 📅 날짜

- 2025-01-22

---

## ✏️ 배운 것

# 객체지향 설계의 SOLID 원칙

SOLID는 객체지향 설계에서 유지보수성과 확장성을 높이기 위한 5가지 원칙을 의미

## 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)

- 하나의 클래스는 하나의 책임만 가져야 합니다.
- 예: 사용자 관리 클래스는 사용자 관련 기능만 수행해야 하며, 이메일 전송 기능은 다른 클래스로 분리해야 합니다.

## 2. 개방-폐쇄 원칙 (Open/Closed Principle, OCP)

- 소프트웨어 구성 요소는 **확장에는 열려** 있어야 하지만, **수정에는 닫혀** 있어야 합니다.
- 예: 새로운 기능 추가 시 기존 코드를 변경하지 않고 확장할 수 있어야 합니다.

## 3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

- 자식 클래스는 부모 클래스를 대체할 수 있어야 합니다.
- 예: 상속받은 하위 클래스는 부모 클래스의 기능을 문제없이 수행할 수 있어야 합니다.

## 4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)

- 클라이언트가 자신이 사용하지 않는 인터페이스에 의존하지 않도록 설계해야 합니다.
- 예: 하나의 거대한 인터페이스보다 여러 개의 작은 인터페이스로 분리하는 것이 좋습니다.

## 5. 의존 역전 원칙 (Dependency Inversion Principle, DIP)

- 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화에 의존해야 합니다.
- 예: 특정 구현 클래스 대신 인터페이스를 사용하여 의존성을 줄입니다.

---

# Redis vs MySQL 비교

## 1. 개요

| 항목     | Redis               | MySQL               |
|--------|---------------------|---------------------|
| 유형     | 인메모리 데이터베이스 (NoSQL) | 관계형 데이터베이스 (SQL)    |
| 데이터 모델 | 키-값 (Key-Value)     | 테이블 기반 (Relational) |
| 주 용도   | 캐싱, 세션 관리, 실시간 분석   | 트랜잭션 처리, 데이터 영속성    |

## 2. 주요 차이점

### 성능

- **Redis**: 메모리 기반으로 작동하므로 매우 빠른 읽기/쓰기 속도를 제공합니다.
- **MySQL**: 디스크 기반 저장소이므로 속도가 상대적으로 느립니다.

### 데이터 영속성

- **Redis**: 주로 메모리에서 실행되지만, AOF 및 RDB를 통해 영속성 제공 가능.
- **MySQL**: 디스크 기반 저장으로 영속성을 기본 제공.

### 트랜잭션 지원

- **Redis**: 기본적인 트랜잭션 지원은 가능하지만 복잡한 ACID 특성은 제한적입니다.
- **MySQL**: 완전한 ACID 트랜잭션 지원.

### 데이터 구조

- **Redis**: 다양한 자료구조(리스트, 해시, 셋, 정렬된 셋 등)를 지원.
- **MySQL**: 정형화된 스키마(테이블, 컬럼)를 기반으로 함.

### 확장성

- **Redis**: 수평적 확장(클러스터링)을 통한 성능 향상 용이.
- **MySQL**: 수직적 확장(스케일업)이 일반적이며, 샤딩 및 복제를 통해 수평 확장 가능.

---

## 📅 날짜

- 2025-01-23

---

## ✏️ 배운 것

## 1. IntelliJ 환경설정에서의 어려움

오늘은 IntelliJ 환경설정에서 여러 가지 어려움을 겪었다. 특히 **Gradle 설정, JDK 버전 문제, 환경변수 설정, 그리고 실행 시 발생하는 오류들**로 인해 많은 시간을 소비했다.
어제는 분명히 잘 됐는데 오늘은 git을 통해 코드를 받아오는 과정 어딘가에서 충돌이 났던것 같다.

### 1.1 cannot resolve symbol 오류 및 해결 과정

서버쪽 코드를 실행할때 `cannot resolve symbol` 오류가 발생했는데, 이는 주로 **의존성 문제**, **Gradle 동기화 문제**, **IDE 캐시 문제**로 인해 발생한다는 사실을 알게 되었다.

#### 해결 과정

1. **의존성 확인 및 재설정**  
   `build.gradle`에 필요한 의존성이 올바르게 추가되어 있는지 확인하고, 의존성을 강제로 새로고침하였다.

   ```bash
   ./gradlew clean build --refresh-dependencies
   ```

2. **IntelliJ 캐시 삭제 및 재시작**
    - `File > Invalidate Caches / Restart` 기능을 활용해 캐시 문제를 해결.

3. **애노테이션 프로세서 설정**
    - Lombok 관련 `cannot resolve symbol` 오류는 다음과 같이 해결하였다.  
      `Settings > Build, Execution, Deployment > Compiler > Annotation Processors`에서  
      **"Enable annotation processing"**을 활성화.

이러한 조치를 통해 코드가 정상적으로 컴파일되고 실행될 수 있었다. 그치만 아직까지 정확히 뭘 해서 고쳐진건지 의문이다. 이것저것 하다보니 다시 오류없이 실행됐는데 오류 해결은 항상 어렵다..

---

### 1.2 새로운 macOS 환경에서의 서버 실행 문제

일과때는 **Windows 환경**에서 개발을 진행했지만, 집에와서 macOS에서 서버를 실행하려다 보니 **JDK 설정 및 환경변수 문제**를 겪었다.  
macOS에서는 Homebrew를 사용하여 JDK를 설치했지만, 프로젝트에서 JDK 17을 요구하는 반면 시스템 기본 JDK가 21로 설정되어 있어 충돌이 발생했다.

#### 해결 과정

1. **프로젝트에 JDK 17 설정**
    - IntelliJ의 `File > Project Structure > Project`에서 **SDK를 JDK 17**로 명확히 지정.

2. **Gradle JVM 확인 및 설정**
    - `File > Settings > Build, Execution, Deployment > Build Tools > Gradle`에서 JDK 17을 선택 후 Gradle 동기화.

3. **환경변수 설정**  
   터미널에서 아래 명령어를 사용하여 JDK 17을 기본으로 설정:

   ```bash
   export JAVA_HOME=$(/usr/libexec/java_home -v 17)
   export PATH=$JAVA_HOME/bin:$PATH
   ```

   이를 영구적으로 적용하기 위해 `~/.zshrc` 파일에 추가 후 적용:

   ```bash
   source ~/.zshrc
   ```

4. **Gradle의 JDK 명시적 지정**  
   `gradle.properties` 파일에 다음 내용을 추가:

   ```properties
   org.gradle.java.home=/Library/Java/JavaVirtualMachines/openjdk-17.jdk/Contents/Home
   ```

이러한 설정 조정을 통해 해결하려 노력했지만 결국 실패했다. 사실 코드 작성보다 이런 환경세팅 설정문제가 발생하면 해결하는데 더 힘이 드는것 같다.

---

## 2. 해야 할 것: Redis DB 연결

내일 진행할 작업은 **Redis 데이터베이스 연결**이다.

### 2.1 작업 계획

1. **Spring Boot Redis 의존성 추가**

   ```gradle
   implementation 'org.springframework.boot:spring-boot-starter-data-redis'
   ```

2. **Redis 설정 추가 (application.yml)**

   ```yaml
   spring:
     redis:
       host: localhost
       port: 6379
   ```

3. **Redis 클라이언트 테스트 및 적용**
    - `RedisTemplate` 또는 `StringRedisTemplate`을 이용한 데이터 저장 및 조회 테스트 진행.

---

- 오늘의 경험을 통해 macOS 환경에서의 개발 환경 설정이 Windows와 다르다는 점을 체감했고, JDK 설정 및 Gradle 환경 설정의 중요성을 다시 한번 인식하게 되었다.
- 오늘 코드 작성부분에서 팀에 도움이 안된것 같아 미안한 감정이 있다. 내일은 정신 똑바로 차리고 더 열심히 할 계획이다.

---

## 📅 날짜

- 2025-01-24

---

## ✏️ 배운 것

## 오늘 배운 내용
Spring Security의 설정 파일에서 **세션 관리(Session Management)** 관련 설정을 살펴보면서 다음과 같은 내용을 학습하였다.

### 1. `stateless` 모드
- **설명**: 서버가 세션을 생성하지 않고, 클라이언트의 모든 요청은 독립적이다.
- **특징**:
    - 인증 정보는 주로 JWT(JSON Web Token) 또는 OAuth 토큰을 이용하여 처리됨.
    - 서버 측 상태를 유지하지 않으므로 확장성이 뛰어남.
    - CSRF(Cross-Site Request Forgery) 방어가 필요하지 않음.
- **설정 방법**:
  ```java
  http
      .sessionManagement()
      .sessionCreationPolicy(SessionCreationPolicy.STATELESS);
  ```
- **장점**:
    - 서버 부하 감소 (세션 저장소 불필요)
    - 마이크로서비스 아키텍처에 적합

### 2. `ifRequired` 모드
- **설명**: 기본적으로 세션을 생성하지 않지만, 필요할 경우에만 생성함.
- **특징**:
    - 첫 번째 요청에서는 세션이 없으나, 인증이 필요하면 생성 가능.
    - 상태 기반 접근이 필요한 경우 유용함.
    - 로그인 후 세션이 유지될 수 있음.
- **설정 방법**:
  ```java
  http
      .sessionManagement()
      .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);
  ```
- **장점**:
    - 필요할 때만 세션을 사용하여 메모리 절약
    - 로그인 기반 서비스에 적절

### 3. `always` 모드
- **설명**: 요청이 오면 항상 새로운 세션을 생성함.
- **특징**:
    - 모든 요청에 대해 세션이 필요할 때 사용
    - 상태 기반 애플리케이션에 적합

### 4. `never` 모드
- **설명**: 애플리케이션에서 직접 세션을 생성하지 않으며, 기존 세션만 사용 가능함.
- **특징**:
    - 세션 생성이 필요하지 않은 경우 사용
    - 외부 시스템이 세션을 관리할 때 유용

## 결론
Spring Security에서 세션 관리는 애플리케이션의 아키텍처에 따라 적절한 설정이 필요하다. 특히 **REST API** 기반 서비스에서는 `stateless` 모드가 일반적이며, 필요에 따라 `ifRequired`를 사용할 수 있다.

## 📅 날짜

- 2025-01-31

---

## ✏️ 배운 것

# Docker란?

Docker는 **컨테이너 기반의 가상화 기술**을 제공하는 플랫폼이다.  
애플리케이션과 실행 환경을 하나의 단위로 패키징하여 **어디서든 일관되게 실행**할 수 있도록 한다.

### Docker의 주요 특징
1. **경량 가상화**  
   Docker 컨테이너는 운영체제(OS) 커널을 공유하므로 가볍고 빠르게 실행된다.  
   이는 기존의 가상머신(VM)이 OS를 포함한 이미지를 실행해야 하는 방식과 다르다.

2. **빠른 컨테이너 생성**  
   컨테이너는 몇 초 만에 생성 및 실행할 수 있어 애플리케이션 배포 및 테스트 시간을 크게 단축한다.

3. **이식성**  
   Docker 이미지를 사용하면 동일한 환경을 어디서든 재현 가능하며, 개발 환경과 배포 환경 간의 차이를 줄여준다.

4. **리소스 효율성**  
   컨테이너는 VM에 비해 더 적은 리소스를 사용하면서도 독립된 환경을 제공한다.

### Docker와 VM의 차이
- **가상머신(VM)**: 각 VM은 별도의 운영체제(OS)를 실행하며, 무겁고 느리지만 강력한 격리성을 제공한다.
- **Docker 컨테이너**: 호스트 OS의 커널을 공유하며, 가볍고 빠르게 실행된다.  

### 컨테이너 생성 주기
1. Docker 이미지를 기반으로 컨테이너를 생성.
2. 컨테이너는 실행, 중지, 삭제 등의 작업이 가능하다.
3. 삭제 후에도 이미지는 재사용할 수 있어 유연한 배포 및 관리가 가능하다.


