# 📘 TIL (Today I Learned)

## 📅 날짜
- 2025-01-13

---

## ✏️ 배운 것
- Jira는 프로젝트 및 이슈 관리를 위한 도구로, 태스크 생성, 우선순위 설정, 워크플로우 트래킹에 최적화되어 있다.
- 보드(칸반/스크럼)를 활용해 팀의 작업 현황을 시각적으로 파악 가능하다.
- 자동화 규칙 설정으로 반복 작업을 줄이고 효율성을 극대화할 수 있다.

---

## 📅 날짜
- 2025-01-14

---

## ✏️ 배운 것
- 기획 단계에서는 MVP설정이 중요하고, 결국 타겟이 누구인지, 어떤 문제를 해결할 수 있는지 명확히 하는것이 중요하다는 것을 깨달았다.
- 정해진 틀에서 벗어나 새로운 아이디어를 브레인스토밍 하는 과정의 필요성을 느꼈다.
- 키워드 중심의 브레인스토밍이 효과적이라는 것을 깨달았다.

---

## 📅 날짜
- 2025-01-15

---

## ✏️ 배운 것
- 개발을 시작하기 전에 브랜치 전략은 어떤 방법을 사용할 것인지, 커밋 규칙을 어떻게 정할 것인지 결정하는 것이 정말 중요하다라는 것을 깨달았다.
- 브랜치 전략에는 git flow, github flow, gitlab flow가 있고 각각의 전략마다 특징을 알게 되었다.
- Git Flow: 브랜치를 명확히 분리하여 기능 개발, 릴리스, 핫픽스를 관리하는 전통적인 워크플로우 전략.
- GitHub Flow: 메인 브랜치를 중심으로 단순화된 브랜치 전략으로, 항상 배포 가능한 상태를 유지하며 풀 리퀘스트 기반으로 작업.
- GitLab Flow: CI/CD와 통합된 워크플로우로, 환경(예: 개발, 스테이징, 프로덕션)과 릴리스 관리를 중점으로 한 전략.
---

## 📅 날짜
- 2025-01-16

---

## ✏️ 배운 것
- 지라를 활용하여 에픽, 스토리, 테스크를 등록하는 방법과 스프린트 작성법을 알게 되었다.
- 할 일을 정리하고 효율적으로 작업을 수행하기 위한 기법들에 대해 알아보았다.
#### GTD (Getting Things Done) : 정리의 기술
- 할 일을 체계적으로 분류하고 처리하는 데 초점.

#### 아이젠하워 매트릭스 : 우선순위 정리
- 중요도와 긴급성에 따라 작업을 4가지로 구분.

#### 만트라트 (Mantra + Chart) : 훈련과 시각화
- 목표 달성을 위한 반복적 훈련과 차트 기반 관리.(ex : 오타니의 훈련 트레이닝)

#### 포모도로 기법 : 시간 집중 관리
- 25분 집중 + 5분 휴식을 통해 효율적인 작업.

#### 타임박싱 : 데드라인 설정
- 정해진 시간 안에 특정 작업을 끝내는 방법.

#### 타임 블로킹 : 시간 블록 활용
- 특정 시간대를 집중 작업 시간으로 예약.

#### PARA Method : 정보 분류 관리
- 프로젝트, 관심사, 자료, 아카이브로 체계화.

#### 제텔카스텐 : 아이디어 연결
- 독립된 메모를 상호 연결해 창의적 사고를 촉진.
---

## 📅 날짜
- 2025-01-17

---

## ✏️ 배운 것
- 소크라테스의 문답법 : 상대방에게 질문을 던져 진리를 낳도록 돕는 방법
- 프로젝트가 많아야하나? 그건 아니다. Job Description를 확인하고 그에 맞는 프로젝트가 필요하다.
- 프로젝트가 화려해야할까? 반반. 화려함의 기준(새로운것?, 최신기술?)
- 채용시장 트렌드(대규모 공채에서는 눈에띄는게 좋다. 팀별 모집이라면 그 팀에 맞는 기술 스택 or 비슷한 경험이 중요)
- 베이스가 되는 포폴을 하나 만들어 놓고, 지원할때마다 조금씩 튜닝
- 오늘은 팀원들과 유스 케이스를 만들고, 대략적인 API 명세서를 설계하였다.
- WebRTC 개념에 대해 배웠고, 적용 방법에 대해 주말간 열심히 공부해 볼 생각이다.

## 📅 날짜
- 2025-01-20

---

## ✏️ 배운 것
## 인증 및 보안 개념 정리

### 1. 인증 (Authentication)
- 사용자가 누구인지 확인하는 과정.
- 아이디, 비밀번호, 생체 인식 등을 통해 사용자의 신원을 검증.
- 예: 로그인 시 아이디/비밀번호 확인.

### 2. 인가 (Authorization)
- 사용자가 특정 리소스에 접근할 수 있는 권한을 부여하는 과정.
- 권한(role)에 따라 접근 가능 여부 결정.
- 예: 관리자만 특정 페이지에 접근 가능.

### 3. Session Storage
- 웹 브라우저의 메모리에 일시적으로 데이터를 저장하는 방식.
- 세션이 종료되면 데이터가 사라짐.
- 주로 로그인 상태나 임시 데이터를 저장하는 데 사용.

### 4. Cookie
- 클라이언트(브라우저)에서 데이터를 저장하는 작은 파일.
- 상태 유지(세션, 인증 정보)를 위해 서버가 클라이언트에게 전송.
- 주요 속성:
  - `HttpOnly`: JavaScript 접근 차단(XSS 방지)
  - `Secure`: HTTPS 환경에서만 전송
  - `SameSite`: 크로스사이트 요청 제한(CSRF 방지)

### 5. JWT (JSON Web Token)
- 사용자 인증 및 정보 전달을 위한 토큰 기반 인증 방식.
- 구성 요소: `Header`.`Payload`.`Signature`
- 특징:
  - 무상태(stateless) 인증 가능.
  - 클라이언트 측에서 인증 정보 보유 가능.
  - 서버 부담 감소.

### 6. Access Token
- 사용자가 인증된 후 API 요청 시 권한을 검증하는 데 사용되는 토큰.
- 유효 기간이 짧고, 요청마다 헤더에 포함되어 전송.
- 리소스 서버가 이를 기반으로 요청을 승인하거나 거부.

### 7. Refresh Token
- Access Token이 만료되었을 때 새로운 Access Token을 발급받기 위한 토큰.
- 일반적으로 서버 측에서 저장되며, 유효 기간이 길다.
- Access Token이 탈취되어도 피해를 최소화하기 위해 사용.

### 8. Spring Security
- Spring 프레임워크의 보안 모듈로 인증 및 인가 기능 제공.
- 다양한 보안 기능 제공: 로그인, CSRF 방어, 세션 관리, OAuth2 지원.
- 주요 구성 요소:
  - `AuthenticationManager`
  - `SecurityFilterChain`
  - `UserDetailsService`

### 9. OAuth 2.0
- 권한 위임을 위한 표준 프로토콜.
- 사용자가 특정 리소스에 대한 액세스를 제3자 애플리케이션에 위임할 수 있도록 설계.
- 주요 흐름:
  1. 사용자가 클라이언트 애플리케이션에 로그인 요청.
  2. 클라이언트는 권한 코드를 받기 위해 인증 서버로 리디렉션.
  3. 인증 서버는 권한 코드를 제공.
  4. 클라이언트는 권한 코드를 사용해 액세스 토큰을 요청.
  5. 액세스 토큰을 사용하여 리소스 서버에 접근.

### 10. HttpOnly
- 쿠키의 속성으로, JavaScript에서 접근하지 못하도록 제한.
- 보안 강화를 위해 사용되며, XSS 공격 방지에 효과적.

---

## OAuth 주요 구성 요소

1. **Resource Owner (사용자)**: 실제 리소스(데이터)를 소유한 사용자.
2. **Client (클라이언트 애플리케이션)**: 사용자의 리소스를 접근하려는 외부 플랫폼.
3. **Authorization Server (인증 서버)**: 클라이언트가 사용자 리소스를 사용하도록 인증을 처리.
4. **Resource Server (리소스 서버)**: 사용자의 데이터를 제공하는 서버.

---

## 총정리: OAuth 2.0과 HttpOnly 쿠키 기반 인증 흐름

1. **사용자가 웹사이트에 로그인 요청(인증, Authentication).**
2. 클라이언트(예: 웹사이트)는 OAuth 2.0을 통해 인증 서버(Authorization Server)로 리디렉션.
3. 사용자가 로그인 후, 인증 서버는 클라이언트에 인증 코드(Authorization Code)를 제공.
4. 클라이언트는 인증 코드를 백엔드 서버로 전송하고, 백엔드 서버는 이를 이용해 인증 서버에 액세스 토큰과 리프레시 토큰을 요청.
5. 서버는 Access Token을 **HttpOnly 쿠키**에 저장하여 클라이언트가 직접 접근할 수 없도록 보호.
6. 클라이언트는 이후 API 요청 시 브라우저에서 자동으로 쿠키를 전송하고, 서버는 이를 검증하여 접근을 허용.
7. Access Token이 만료되면 클라이언트는 Refresh Token을 사용하여 새로운 Access Token을 발급받음.
8. 리소스 서버(Resource Server)는 Access Token을 검증하고 사용자 리소스를 제공.
9. Spring Security는 이러한 흐름을 관리하며, OAuth 2.0 프로토콜과 HttpOnly 쿠키를 통해 보안 강화.

---

## 📅 날짜
- 2025-01-21

---

## ✏️ 배운 것
- Spring Security는 스프링 애플리케이션에서 인증(Authentication)과 인가(Authorization)을 제공하는 보안 프레임워크이다.
- OAuth 2.0은 사용자의 자격 증명을 외부 인증 서버(예: 카카오, 구글)에 위임하여 보안 강화를 지원하는 인증 프로토콜이다.
- Spring Security는 OAuth 2.0과 통합하여 소셜 로그인 기능을 쉽게 구현할 수 있으며, 사용자 정보를 보호하기 위해 JWT 및 HttpOnly 쿠키를 활용할 수 있다.
- OAuth 인증 후 서버에서 발급받은 액세스 토큰을 활용하여 API 요청을 수행하고, 리프레시 토큰으로 만료 시 갱신을 관리할 수 있다.
- 보안 강화를 위해 CORS 설정, CSRF 방어, 권한 기반 접근 제어 및 로깅을 함께 설정하여 보다 안전한 애플리케이션을 구축할 수 있다.