# 📘 TIL (Today I Learned)

## 📅 2025.01.13.MON

- 프로젝트의 기획이 생각보다 고려해야 할 점이 많다는 것을 깨달았던 하루였습니다...
- JIRA 사용법에 대해 아직 익숙하지 않은 상태였는데, 에픽, 백로그 등의 개념 및 간단한 사용 방법들을 배워보고 실습해보았습니다.
  <br/>
  <br/>

## 📅 2025.01.14.TUE

### PM 특강

1. 문제해결/협력

   1. 특징
      - win-win (최선의 선택)
      - 아이디어나 정보 공유
      - 문제나 갈등을 도전의 기회로 인식
   2. 선택해야 하는 상황
      - 이해관계자에게 중대하고 반드시 극복해야 하는 갈등이 있을 때
      - 갈등해결 과정이 배움으로 큰 의미를 가질 때
      - 프로젝트 계획수립 단계의 핵심 의사결정
   3. 주의 사항
      - 갈등 해결에 오랜 시간과 노력이 필요

2. 강압/경쟁

   1. 특징
      - 내가 옳고 상대가 틀린 것을 분명히 함
      - 권력/지위를 사용
      - 상대의 굴복을 강요
   2. 선택해야 하는 상황
      - 긴급한 의사결정을 해야 하는 갈등 (안전과 관련된 사안)
      - 모든 이해관계자가 하기 싫어하는 일을 해야 할 때 (원가절감 등)
      - 내가 경쟁에서 승리할 확률이 최소 70% 이상일 때
   3. 주의 사항
      - 부정적인 효과가 매우 오래 지속됨

3. 회피/지연

   1. 특징
      - 조만간 없어지리라 생각할 때
      - 해결책을 모색하는 중일 때
      - 문제를 회피하는 모습을 감춰야 하는 경우
   2. 선택해야 하는 상황
      - 사소하거나 중요도가 낮은 갈등
      - 갈등으로 감정이 이미 격양된 상태일 때
      - 갈등 해결의 가망성이 매우 희박한 경우
   3. 주의 사항
      - PM이 매우 소극적인 사람으로 인식될 수 있음

4. 수용/수습

   1. 특징
      - 내 잘못이 분명할 때
      - 항복할 때
      - 아쉽지만 협력관계를 유지할 필요가 있을 때
   2. 선택해야 하는 상황
      - 과거에 대한 교훈과 미래의 신뢰를 구축해야 하는 상황
      - 내 잘못이 명백하여 조직 내 평판이 나빠지는 것을 막아야 하는 경우
   3. 주의 사항
      - 태도의 진정성에 대해 의심받을 수 있음 (금전적 보상을 함께하자...)

5. 타협/절충 1) 특징 - 갈등이 애매한 경우 - 협상할 때 - 거래나 교환을 추구하는 경우 2) 선택해야 하는 상황 - 중요한 갈등이나 해결을 위한 노력을 최소화 하고 싶을 때 - 갈등의 상대방과 대등한 힘을 가지고 동일한 목표를 추구할 때 - 시간 압박이 있는 상황에서 무난한 결론이 필요할 때 3) 주의 사항 - 협력 or 경쟁으로 전환하기 위한 잠복 단계
   <br/>
   <br/>

## 📅 2025.01.15.WED

### PM 특강

1. 어떤 프로젝트 팀이 월등한 성과를 이루는가?

   1. 구조 및 명확성: 분명한 목표와 역할
   2. 상호 의존성: 서로 역량을 신뢰할 수 있는 구성원 선발
   3. 일의 의미: 자신의 일에 대하여 개인적 의미를 부여
   4. 일의 영향: 프로젝트가 중요하고 변화를 만드는 것이라는 믿음
   5. 심리적 안전감: 약점을 공개해도 불이익 받지 않는 팀 분위기

2. 프로젝트 종료 단계에서 팀장이 가져야 할 마음가짐 1) 리더로서의 책임감 2) 품질에 대한 직접적인 확인 3) 종료는 프로젝트 안에서 새로운 프로젝트 시작
   <br/>
   <br/>

## 📅 2025.01.16.THU

### 일의 효율성을 높이는 방법

1. GTD
2. 일의 중요도 결정
3. 만트라트
4. 뽀모도로
   - 1 cycle: 25분 집중 + 5분 휴식
   - 4 cycle 수행하면 길게 휴식
5. 타임박싱
6. 타임 블로킹
   - 나만의 시간을 확보해놓기
7. PARA method
   - project, area, resource, archive
8. 제텔카스텐 (메모상자) - 임시적, 영구적인 메모를 수시로 작성 - 연관된 메모들을 index 카드로 관리 - 연관된 메모들끼리도 서로 가리키도록 기록
   <br/>
   <br/>

## 📅 2025.01.17.FRI

### MediaRecorder의 데이터 저장 방식

- `MediaRecorder`는 녹화를 시작할 때 `start(timeslice)`를 설정하면 해당 `timeslice(ms)`마다 `ondataavailable` 이벤트를 통해 Blob 데이터를 생성한다.
- `ondataavailable에서` 받은 `event.data`를 IndexedDB에 저장하면, 녹화된 비디오를 저장 및 재생할 수 있다.

### IndexedDB 트랜잭션 관리

- IndexedDB에 데이터를 저장하려면 `transaction`을 생성하고, 그 안에서 데이터를 `add()`해야 한다.
- `TransactionInactiveError`는 트랜잭션이 닫힌 후 데이터를 저장하려고 할 때 발생한다.

### IndexedDB에서 Blob 데이터를 올바르게 복원하는 방법

- IndexedDB에서 데이터를 가져올 때, Blob을 저장하면 MIME 타입 정보가 손실될 수 있다.
- Blob을 `arrayBuffer()`로 변환해 저장하고, 다시 Blob으로 복원해야 한다.

### MediaRecorder의 중복 실행 방지

- `mediaRecorder.stop()`을 `ondataavailable` 내부에서 호출하면 새로운 녹화가 시작될 때마다 중복 실행이 발생할 수 있다.
- `startRecording()` 내에서 `mediaRecorder.start(5000)`을 한 번만 실행해야 한다.
  <br/>
  <br/>

## 📅 2025.01.20.MON

### Git Branch 전략

#### 1. Git Flow

- `main` 브랜치는 안정적인 배포 버전을 유지하고, `develop` 브랜치에서 개발을 진행한다.
- `feature/{기능명}` 브랜치를 생성해 기능 개발 후, `develop`에 머지한다.
- `release/{버전명}` 브랜치를 만들어 QA 및 테스트를 진행하고, 검증이 끝나면 `main`과 `develop`에 병합한다.
- `hotfix/{버그명}` 브랜치는 배포된 `main`에서 긴급 버그 수정 시 사용된다.

#### 2. GitHub Flow

- `main` 브랜치에서 직접 `feature/{기능명}` 브랜치를 생성하고, PR(Pull Request)을 통해 병합한다.
- CI/CD 환경과 잘 맞으며, 빠른 개발 주기에 적합하다.
- `hotfix` 브랜치는 필요 시 `main`에서 직접 생성하여 버그를 수정한 후 배포한다.

#### 3. GitLab Flow

- `main` 브랜치는 항상 배포 가능한 상태를 유지하며, `feature` 브랜치는 필요할 때 생성한다.
- `production`, `staging` 브랜치를 추가하여 배포 환경별 코드 분리를 지원한다.
- `environment` 기반으로 브랜치를 나누어, 특정 환경에서만 테스트할 수 있도록 한다.

#### 4. Trunk-Based Development

- `main` 브랜치에서 직접 개발하며, 작은 단위로 빈번한 병합을 수행한다.
- 브랜치 생성을 최소화하고, `feature flag`를 활용해 미완성 기능을 비활성화한 채 배포할 수 있다.
- 대규모 협업 프로젝트에서 CI/CD를 활용한 지속적인 배포에 적합하다.
  <br/>
  <br/>

## 📅 2025.01.21.TUE

### JavaScript 및 TypeScript의 컴파일 동작 과정

- JavaScript는 인터프리터 언어이지만, V8 엔진 등에서 Just-In-Time(JIT) 컴파일을 통해 실행 속도를 최적화한다.
- TypeScript는 정적 타입을 제공하며, `tsc`(TypeScript Compiler)를 사용해 JavaScript 코드로 변환된다.
- `tsc`는 코드의 타입 검사를 수행한 후, 설정된 `target` 버전에 맞게 ES5, ES6 등으로 변환한다.
- TypeScript의 `strict` 옵션을 활성화하면 더 엄격한 타입 검사를 적용할 수 있다.

### Babel과 SWC의 비교

- `Babel`과 `SWC`는 모두 JavaScript/TypeScript 코드를 트랜스파일하는 도구지만, 동작 방식과 성능이 다르다.
- `Babel`은 AST(Abstract Syntax Tree) 기반으로 변환하며, 플러그인을 활용해 다양한 변환 작업을 수행할 수 있다.
- `SWC(Speedy Web Compiler)`는 Rust 기반으로 작성되어 있으며, Babel보다 빠른 변환 속도를 제공한다.
- `SWC`는 멀티스레딩을 활용하여 성능을 극대화하며, 최근 Next.js에서 기본 트랜스파일러로 채택되었다.
- `Babel`은 플러그인 확장성이 뛰어나며, `@babel/preset-env`를 활용하면 브라우저 호환성을 조정할 수 있다.
- `SWC`는 설정이 간단하며, 특히 대규모 프로젝트에서 빌드 속도를 크게 개선할 수 있다.
  <br/>
  <br/>

## 📅 2025.01.22.WED

### React Context API vs. Zustand

#### 1. React Context API

- Context API는 전역 상태 관리를 위해 `React.createContext()`를 사용하여 데이터를 제공(provide)하고 소비(consume)할 수 있도록 한다.
- `useContext()` 훅을 사용하여 원하는 컴포넌트에서 상태를 불러올 수 있다.
- Redux와 같은 외부 라이브러리 없이 상태를 관리할 수 있지만, 상태 변경 시 전체 컴포넌트가 리렌더링될 가능성이 있다.
- `useReducer()`와 함께 사용하면 보다 구조적인 상태 관리가 가능하다.

#### 2. Zustand

- `Zustand`는 React에서 가벼운 상태 관리를 지원하는 라이브러리로, Redux보다 간단한 API를 제공한다.
- `create()` 함수를 통해 전역 상태를 정의하고, `useStore()` 패턴으로 특정 상태를 쉽게 가져올 수 있다.
- `Context API`보다 리렌더링이 적으며, 상태 변경이 발생한 컴포넌트만 렌더링된다.
- 미들웨어를 지원하며, Immer와 결합하여 불변성 관리를 쉽게 할 수 있다.

#### 🔍 Context API vs. Zustand 비교

| 비교 항목       | Context API                    | Zustand                     |
| --------------- | ------------------------------ | --------------------------- |
| 상태 저장 방식  | `Context.Provider`             | `create()` 함수 활용        |
| 리렌더링 최적화 | 없음 (전체 리렌더링 발생 가능) | 있음 (변경된 상태만 렌더링) |
| 사용 편의성     | 비교적 복잡한 설정 필요        | 간단한 API 제공             |
| 미들웨어 지원   | 직접 구현 필요                 | 기본 제공                   |
| 데이터 구조     | `useReducer()`로 구조화 가능   | Flux 패턴 기반              |

---

### React-Router-Dom의 동작 원리

#### 1. 기본 개념

- `react-router-dom`은 SPA(Single Page Application)에서 페이지 전환을 구현하기 위해 사용된다.
- 브라우저의 `history API`를 활용하여 URL을 변경하지만, 페이지를 새로고침하지 않는다.
- 주요 컴포넌트:
  - `<BrowserRouter>`: `history API`를 사용하여 경로 변경을 감지한다.
  - `<Routes>`: 여러 개의 `<Route>`를 감싸는 컨테이너 역할을 한다.
  - `<Route>`: 특정 URL 경로에 따라 렌더링할 컴포넌트를 지정한다.
  - `<Link>`: `a` 태그를 대체하며, 페이지 리로드 없이 경로를 변경할 수 있다.
  - `useNavigate()`: 프로그래밍 방식으로 라우팅을 변경할 수 있다.

#### 2. 동작 방식

1. 사용자가 `<Link to="/about">`을 클릭하면, `history.pushState()`가 실행되면서 URL이 변경된다.
2. `BrowserRouter`는 `window.onpopstate` 이벤트를 감지하여 `Routes` 내부의 활성화된 `<Route>`를 다시 렌더링한다.
3. `Route` 내부에서 `path`가 현재 URL과 일치하면 해당 컴포넌트를 렌더링한다.
4. 새로고침 시 서버의 404 오류를 방지하기 위해, `server-side fallback` 설정이 필요할 수 있다.

#### 3. Route Matching 방식

- `react-router-dom`은 기본적으로 가장 먼저 매칭된 라우트를 렌더링한다.
- `exact` 속성이 필요 없으며, `<Routes>` 내부에서 가장 정확한 경로를 자동 선택한다.
- 동적 라우팅 (`/users/:id`)을 지원하며, `useParams()` 훅으로 URL 파라미터를 가져올 수 있다.

#### 🔍 React-Router-Dom의 특징

| 비교 항목          | 설명                                  |
| ------------------ | ------------------------------------- |
| URL 변경 방식      | `history.pushState()` 활용            |
| 전체 리렌더링 여부 | 필요 없음, 변경된 부분만 렌더링       |
| 동적 라우팅 지원   | `/users/:id` 같은 동적 경로 사용 가능 |
| 네비게이션 방식    | `<Link>` 및 `useNavigate()` 사용      |

  <br/>
  <br/>

## 📅 2025.01.23.THU

### UX/UI 디자인 원칙

#### 1. UX(User Experience) 디자인 원칙

UX는 사용자의 경험을 최적화하는 것을 목표로 하며, 직관적이고 효율적인 인터페이스를 제공해야 한다.

##### ✅ 가독성과 접근성 (Readability & Accessibility)

- 사용자가 정보를 쉽게 읽고 이해할 수 있도록 가독성을 높인다.
- 색맹, 시각 장애 등을 고려하여 대비(contrast)와 색상 조합을 신중하게 선택한다.
- WAI-ARIA 표준을 준수하여 보조 기술을 지원한다.

##### ✅ 직관적인 내비게이션 (Intuitive Navigation)

- 사용자가 최소한의 학습으로 원하는 기능을 쉽게 찾을 수 있도록 내비게이션을 설계한다.
- 메뉴는 계층적 구조를 고려하여 정리하고, 탐색 경로를 명확하게 제공한다.
- 일관된 아이콘과 용어를 사용하여 혼동을 줄인다.

##### ✅ 피드백과 응답성 (Feedback & Responsiveness)

- 버튼 클릭, 입력 오류 등의 인터랙션에 즉각적인 피드백을 제공한다.
- 로딩 중 진행 상태를 표시하여 사용자가 현재 상태를 이해할 수 있도록 한다.
- 다양한 디바이스에서 최적의 UX를 제공할 수 있도록 반응형 디자인을 적용한다.

---

#### 2. UI(User Interface) 디자인 원칙

UI는 시각적인 요소와 인터랙션을 포함하여 사용자가 시스템을 효과적으로 사용할 수 있도록 돕는 역할을 한다.

##### ✅ 일관성 (Consistency)

- 버튼, 폰트, 색상, 간격 등을 일관되게 유지하여 사용자가 예측 가능한 경험을 하도록 한다.
- 동일한 기능을 수행하는 UI 요소는 동일한 형태로 유지한다.
- 플랫폼의 디자인 가이드라인(Material Design, Human Interface Guidelines 등)을 따르는 것이 중요하다.

##### ✅ 미니멀리즘 (Minimalism)

- 불필요한 요소를 제거하고, 핵심 기능에 집중하여 간결한 디자인을 유지한다.
- 한 화면에 너무 많은 정보를 배치하지 않고, 사용자 목표에 맞는 핵심 요소만 제공한다.
- 여백(Whitespace)을 적극 활용하여 시각적 부담을 줄인다.

##### ✅ 시각적 계층 구조 (Visual Hierarchy)

- 중요한 정보는 강조(굵기, 색상, 크기)하여 사용자의 시선을 유도한다.
- F-패턴 및 Z-패턴과 같은 시각적 흐름을 고려하여 배치한다.
- CTA(Call to Action) 버튼을 눈에 띄게 배치하여 사용자의 행동을 유도한다.

---

### ✅ UX/UI 디자인 원칙 비교

| 원칙          | UX (사용자 경험)                  | UI (사용자 인터페이스)             |
| ------------- | --------------------------------- | ---------------------------------- |
| 목표          | 사용자 편의성과 효율성 향상       | 심미적이고 직관적인 화면 제공      |
| 접근성        | 누구나 쉽게 사용할 수 있도록 보장 | 시각적 요소로 정보 전달            |
| 내비게이션    | 빠르고 직관적인 경로 제공         | 메뉴, 버튼 등 인터페이스 구성      |
| 피드백        | 즉각적인 반응 및 상태 표시        | 애니메이션, 마이크로 인터랙션 활용 |
| 디자인 일관성 | 전체적인 사용 흐름을 통일         | 색상, 아이콘, 폰트 스타일 유지     |

  <br/>
  <br/>

## 📅 2025.01.24.FRI

### 애자일 방법론 (Agile Methodology)

#### 1. 애자일 방법론이란?

- 애자일(Agile)은 **변화에 유연하게 대응하고, 지속적인 개선을 통해 가치를 극대화하는 개발 방법론**이다.
- 2001년 발표된 **애자일 선언(Agile Manifesto)**를 기반으로, 소프트웨어 개발뿐만 아니라 다양한 분야에서 활용된다.

#### 2. 애자일 선언 (Agile Manifesto)

애자일 선언에서는 **전통적인 개발 방식(Waterfall)과 대비되는 네 가지 핵심 가치를 제시**한다.

✅ **애자일 4대 가치**

1. **프로세스와 도구보다 개인과 상호작용(Individuals and interactions over processes and tools)**
   - 개발 도구나 프로세스보다 팀원 간 협업과 소통을 우선한다.
2. **포괄적인 문서보다 실행 가능한 소프트웨어(Working software over comprehensive documentation)**
   - 문서화보다는 실제 작동하는 소프트웨어를 빠르게 제공하는 것이 중요하다.
3. **계약 협상보다 고객과의 협력(Customer collaboration over contract negotiation)**
   - 고객과 긴밀히 협력하여 요구사항을 유연하게 반영한다.
4. **계획을 따르는 것보다 변화에 대한 대응(Responding to change over following a plan)**
   - 초기 계획보다 변화하는 요구사항을 반영하여 최적의 결과를 도출한다.

#### 3. 애자일 방법론의 주요 특징

✅ **반복적 개발(Iterative Development)**

- 프로젝트를 작은 단위(Iteration)로 나누어 주기적으로 개발 및 개선을 반복한다.

✅ **고객 중심(Customer Collaboration)**

- 고객 피드백을 적극 반영하여 최종 제품이 사용자 요구사항을 충족하도록 한다.

✅ **자율성과 협업(Self-organizing & Collaboration)**

- 개발팀이 자율적으로 작업을 수행하며, 팀원 간 원활한 협업이 이루어진다.

✅ **우선순위 기반 개발(Prioritization)**

- 요구사항을 지속적으로 평가하고, 가장 중요한 기능부터 개발하여 빠르게 제공한다.

---

### 4. 애자일 프레임워크 (Agile Frameworks)

애자일 원칙을 기반으로 한 다양한 프레임워크가 존재한다.

#### ✅ 스크럼 (Scrum)

- 가장 널리 사용되는 애자일 프레임워크로, 정해진 기간 동안 목표를 설정하고 개발하는 **스프린트(Sprint)** 방식이다.
- 주요 역할:
  - **Product Owner**: 요구사항 정의 및 우선순위 설정
  - **Scrum Master**: 애자일 프로세스가 원활히 진행되도록 지원
  - **Development Team**: 실제 개발을 수행하는 팀원
- 핵심 이벤트:
  - **스프린트 계획(Sprint Planning)**: 작업 목표 설정
  - **데일리 스크럼(Daily Scrum)**: 팀원 간 진행 상황 공유
  - **스프린트 리뷰(Sprint Review)**: 개발 결과물 시연 및 피드백 반영
  - **스프린트 회고(Sprint Retrospective)**: 개선점을 논의하고 다음 스프린트에 반영

#### ✅ 칸반 (Kanban)

- **작업 흐름(Workflow)을 시각화**하여 진행 상황을 명확하게 파악할 수 있도록 한다.
- Trello, Jira와 같은 도구를 활용하여 `To Do → In Progress → Done`의 방식으로 업무를 관리한다.
- WIP(Work In Progress) 제한을 설정하여 **병목 현상을 방지**하고 지속적인 개선을 유도한다.

#### ✅ 익스트림 프로그래밍 (XP, Extreme Programming)

- 짧은 개발 주기와 철저한 테스트를 통해 품질을 높이는 방법론이다.
- 핵심 원칙:
  - **테스트 주도 개발(TDD, Test-Driven Development)**: 테스트를 먼저 작성한 후 코드 구현
  - **짝 프로그래밍(Pair Programming)**: 두 명이 함께 코드 작성 및 리뷰
  - **지속적 통합(Continuous Integration)**: 변경 사항을 자주 병합하여 오류를 방지

---

### 5. 애자일 vs. 워터폴 비교

| 비교 항목   | 애자일(Agile) | 워터폴(Waterfall)     |
| ----------- | ------------- | --------------------- |
| 개발 방식   | 반복적 개발   | 순차적 개발           |
| 변화 대응   | 유연함        | 고정됨                |
| 고객 협업   | 지속적인 참여 | 계약 완료 후 진행     |
| 피드백 반영 | 빠르게 반영   | 사전 계획에 따라 진행 |
| 문서화      | 최소화        | 상세 문서 작성        |
| 개발 속도   | 빠름          | 상대적으로 느림       |

---

### 6. 애자일 도입 시 고려할 점

- 조직 문화가 변화에 개방적이어야 한다.
- 팀원 간 원활한 협업과 커뮤니케이션이 필수적이다.
- 프로젝트 성격에 따라 적절한 애자일 프레임워크를 선택해야 한다.
- 지속적인 개선과 피드백 반영이 이루어져야 한다.
